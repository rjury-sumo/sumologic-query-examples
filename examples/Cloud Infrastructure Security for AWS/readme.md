# Cloud Infrastructure Security for AWS
## Sumo Logic App For: Cloud Infrastructure Security for AWS
This app provides visibility into your AWS environment to give you insights into active threats, security control failures, and suspicious activity.
Docs Link: [Cloud Infrastructure Security for AWS](https://help.sumologic.com/cid/1097)

## Searches

### Log Searches

- **Action Plan: Security Control Failures**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Admin Privileges Granted**: from Search: Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Admin Privileges Granted 
- **All AWS API Events By Time**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Cloud SIEM Insights**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Config Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Config Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **Config Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **Console Logins from Risky Geo Locations**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity 
- **Console Logins Without MFA**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity 
- **Console Logins Without MFA**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Console Logins Without MFA**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity 
- **Control Failure Findings Details by Severity**: from Search: Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Control Failure Findings Details by Severity 
- **Creation of IAM Role**: from Search: Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Creation of IAM Role 
- **Deleted resources over time**: from Search: Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Deleted resources over time 
- **Disabled or Scheduled Deletion of CMK**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **Disabled or Scheduled Deletion of CMKs**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Disabled or Scheduled Deletion of CMKs**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **Exposed S3 Bucket Created**: from Search: Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Exposed S3 Bucket Created 
- **Failed Console Logins**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity 
- **Failed Console Logins**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Failed Console Logins**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity 
- **Finding Count**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Security Control Failures - AWS Security Hub 
- **Findings by Category**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Security Control Failures - AWS Security Hub 
- **Findings by Resource**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Security Control Failures - AWS Security Hub 
- **Findings by Resource Type**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Security Control Failures - AWS Security Hub 
- **Findings Trend**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Security Control Failures - AWS Security Hub 
- **Gateway Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Gateway Changes**: from Search: Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Gateway Changes 
- **Gateway Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **Gateway Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **IAM Policy Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **IAM Policy Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **IAM Policy Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **IAM Policy Changes**: from Search: Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/IAM Policy Changes 
- **Impossible Travel Events**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity 
- **Impossible Travel Events**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity 
- **Impossible Travel Events**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Insights - No Action Required**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview 
- **Insights by Assignee**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview 
- **Insights by Created vs Closed**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview 
- **Insights by Entity Type**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview 
- **Insights by Resource**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview 
- **Insights by Rule ID, and Insight Name**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview 
- **Insights by Status**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview 
- **Insights by Tag**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview 
- **Insights Closed**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview 
- **Insights Created**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview 
- **Insights Created - Outlier**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview 
- **Insights Duplicates**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview 
- **Insights False Positives**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview 
- **Least Common Out of Compliance Findings**: from Search: Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Least Common Out of Compliance Findings 
- **Most Common Out of Compliance Findings**: from Search: Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Most Common Out of Compliance Findings 
- **Network ACL Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **Network ACL Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Network ACL Changes**: from Search: Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Network ACL Changes 
- **Network ACL Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **New Admins Added**: from Search: Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/New Admins Added 
- **Permissive S3 Buckets Created**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **Permissive S3 Buckets Created**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Permissive S3 Buckets Created**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **Root Account Logins**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity 
- **Root Account Logins**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity 
- **Root Account Logins**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Route Table Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **Route Table Changes**: from Search: Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Route Table Changes 
- **Route Table Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Route Table Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **S3 Bucket Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **S3 Bucket Changes**: from Search: Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/S3 Bucket Changes 
- **S3 Bucket Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **S3 Bucket Permission Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **Security Control Failures - AWS Security Hub**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Security Group Changes**: from Search: Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Security Group Changes 
- **Security Group Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **Security Group Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **Security Group Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Suspicious Blocked Destinations by Location**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity 
- **Suspicious Blocked Source-Destination Pairs**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity 
- **Suspicious Blocked Source-Destination Pairs**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity 
- **Suspicious Blocked Source-Destination Pairs**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Suspicious Blocked Web Requests**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Web Activity 
- **Suspicious Blocked Web Requests**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Suspicious Blocked Web Requests**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Web Activity 
- **Suspicious Blocked Web Requests by Location**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Web Activity 
- **Suspicious Destinations by Traffic (Megabytes)**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity 
- **Suspicious Megabytes Source-Destination Pairs**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity 
- **Suspicious Traffic (Megabytes)**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity 
- **Threats Count AWS API**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Threats Count AWS Resources**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Threats Count AWS Storage**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Top 10 Closed Insights by Confidence Level**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview 
- **Top 10 Insights Created by Confidence Level**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview 
- **Trend: Blocked Activity Percent**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity 
- **Trend: Blocked Web Requests Percent**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Web Activity 
- **Trend: Suspicious Traffic (Megabytes)**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity 
- **Unauthorized API Requests**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity 
- **Unauthorized API Requests**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **Unauthorized AWS API Requests**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity 
- **VPC Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview 
- **VPC Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity 
- **VPC Changes**: from Search: Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/VPC Changes 
- **VPC Changes**: from Dashboard: Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity

### Metric Searches


## Search Table

|app\_topic|search\_name|type|origin|search|
|:--|:--|:--|:--|:--|
|Cloud Infrastructure Security for AWS|Action Plan: Security Control Failures|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{SecurityHubLogsdatasource}}  ({{cloud.instance.id}} AND {{client.ip}} AND {{user.name}} AND {{cloud.account.id}} AND {{cloud.region}})<br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName", "Resources[0].Details.AwsIamAccessKey.UserName" as cloud.account.id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName, user.name nodrop<br /><br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br />\| parse field=finding\_type "\*/\*/\*" as rule.ruleset, rule.category, rule.name<br /><br />\| if (severity\_normalized == 0, 0, 0) as risk.static\_level<br />\| if (severity\_normalized \> 0.and severity\_normalized \<= 40, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 40 and severity\_normalized \<= 70, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 70 and severity\_normalized \<= 90, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \>= 90, 3, risk.static\_level) as risk.static\_level<br /><br />// global filters<br />\| where if("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if("{{user.name}}" = "\*", true, user.name matches "{{user.name}}")<br />\| where if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) <br /><br />\| format("https://console.aws.amazon.com/securityhub/home?region=%s#/research?Id=%s", sechub\_region, finding\_id) as finding\_url<br />\| tourl(finding\_url, title) as title<br />\| count by title, source,risk.static\_level, updated\_at, resource\_type, finding\_type, resource\_id, cloud.account.id, finding\_provider<br />\| sort by risk.static\_level desc<br />\| fields -\_count<br />\| limit 100|
|Cloud Infrastructure Security for AWS/Saved Searches|Admin Privileges Granted|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Admin Privileges Granted|\_sourceCategory={{CloudTrailLogsdatasource}} <br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage","requestParameters.policyArn" as event\_name,source\_ip,user\_principal, login\_result,mfa\_used,event\_source,aws\_region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,acc\_id,error\_message,policy\_arn nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user\_name<br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where aws\_region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where event\_name matches("\*AttachUserPolicy\*")<br />\| where policy\_arn matches("\*AdministratorAccess\*")<br /><br />\| count by acc\_id,event\_type,user\_name,event\_time,event\_source,aws\_region<br />\| sort by event\_time<br />\| limit 100|
|Cloud Infrastructure Security for AWS|All AWS API Events By Time|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  <br />\| json "requestID","eventID","userIdentity.accountId","userIdentity.type","sourceIPAddress","awsRegion","eventName" as request\_id, event\_id,cloud.account.id,user\_identity\_type,client.ip,cloud.region,event.action<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name <br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br /><br />\| json field=\_raw "requestParameters.dBInstanceIdentifier" as db\_instance\_id nodrop<br />\| json field=\_raw "requestParameters.instancesSet.items[0].instanceId" as cloud\_instance\_id nodrop<br />\| if(isEmpty(db\_instance\_id),cloud\_instance\_id,db\_instance\_id) as cloud.instance.id<br />\| if(isEmpty(cloud.instance.id),"NA", cloud.instance.id) as cloud.instance.id<br /><br />\| parse field=eventSource "\*." as cloud.service.name<br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br /><br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by event.action, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by event.action<br />\| smooth eventCount as eventCount\_mean by event.action<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| fields \_timeslice, event.action, zscore<br />\| sort + \_timeslice<br />\| transpose row \_timeslice column event.action|
|Cloud Infrastructure Security for AWS|Cloud SIEM Insights|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight  insightcreated) OR <br />(\_index=sumologic\_system\_events \_sourcecategory=cseinsight  insightcreated)<br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToDetection" ,"insight.assignee", "operator.email",  "insight.status", "insight.severity", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.entitySensorZone" ,"insight.description",  "insight.name", "insight.readableId", "insight.id",  "insight.confidence"  as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time , insight\_time\_to\_detection , insight\_assignee , operator\_email, insight\_status, insight\_severity, insight\_source, entity\_value, entity\_type, entity\_id, entity\_sensor\_zone ,insight\_description, insight\_name, insight\_readableId, insight\_Id, insight\_confidence nodrop<br />\| json field=\_raw "insight.signals.length()" as signal\_count<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />\| replace(insight\_tags, "[","") as insight\_tags<br />\| replace(insight\_tags, "]","") as insight\_tags<br />\| replace(insight\_tags, "\\"","") as insight\_tags<br />\| replace(insight\_tags, ","," \| ") as insight\_tags<br />\| replace(insight\_ruleId, "[","") as insight\_ruleId<br />\| replace(insight\_ruleId, "]","") as insight\_ruleId<br />\| replace(insight\_ruleId, "\\"","") as insight\_ruleId<br />\| replace(insight\_ruleId, ","," \| ") as insight\_ruleId<br />\| count|
|Cloud Infrastructure Security for AWS|Config Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  ("StopConfigurationRecorder" or "DeleteDeliveryChannel" or "PutDeliveryChannel" or "PutConfigurationRecorder")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "StopConfigurationRecorder" or event.action matches "DeleteDeliveryChannel" or event.action matches "PutDeliveryChannel" or event.action matches "PutConfigurationRecorder"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Config Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("StopConfigurationRecorder" or "DeleteDeliveryChannel" or "PutDeliveryChannel" or "PutConfigurationRecorder")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "StopConfigurationRecorder" or event.action matches "DeleteDeliveryChannel" or event.action matches "PutDeliveryChannel" or event.action matches "PutConfigurationRecorder"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|Config Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("StopConfigurationRecorder" or "DeleteDeliveryChannel" or "PutDeliveryChannel" or "PutConfigurationRecorder")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "StopConfigurationRecorder" or event.action matches "DeleteDeliveryChannel" or event.action matches "PutDeliveryChannel" or event.action matches "PutConfigurationRecorder"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Console Logins from Risky Geo Locations|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ConsoleLogin<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("\*ConsoleLogin\*")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| where isValidIPv4(client.ip) or isValidIPv6(client.ip)<br />\| where !isNull(client.ip)<br />\| if(isValidIPv4(client.ip), if(!isPrivateIP(client.ip),true,false),true) as is\_public<br />\| where is\_public<br />\| count as frequency by client.ip<br />\| lookup latitude, longitude, country\_code from geo://location on ip = client.ip<br />\| lookup country\_code from https://sumologic-app-data.s3.amazonaws.com/riskycountries.csv on country\_code=country\_code<br />\| where !isEmpty(country\_code)|
|Cloud Infrastructure Security for AWS|Console Logins Without MFA|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ConsoleLogin<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("\*ConsoleLogin\*")<br />\| where mfa\_used\<\>"Yes"<br />\| where login\_result = "Success"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|Console Logins Without MFA|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  ConsoleLogin<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br /><br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}")AND if ("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("\*ConsoleLogin\*")<br />\| where mfa\_used\<\>"Yes"<br />\| where login\_result = "Success"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Console Logins Without MFA|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ConsoleLogin<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("\*ConsoleLogin\*")<br />\| where mfa\_used\<\>"Yes"<br />\| where login\_result = "Success"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS/Saved Searches|Control Failure Findings Details by Severity|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Control Failure Findings Details by Severity|\_sourceCategory={{SecurityHubLogsdatasource}}  <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName" as account\_id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName nodrop<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, "Informational", "Others") as severity<br />\| if (severity\_normalized \<= 39, "Low", severity) as severity<br />\| if ((severity\_normalized \<= 69) and (severity\_normalized \>= 40), "Medium", severity) as severity<br />\| if ((severity\_normalized \<= 89) and (severity\_normalized \>= 70), "High", severity) as severity<br />\| if (severity\_normalized \<= 100 and severity\_normalized \>= 90, "Critical", severity) as severity<br /><br />// global filters<br />\| where account\_id matches "\*"<br />\| where finding\_id matches "\*"<br />\| where finding\_type matches "\*"<br />\| where finding\_provider matches "\*"<br />\| where severity matches "\*"<br />\| where compliance\_status matches "\*"<br /><br />\| format("https://console.aws.amazon.com/securityhub/home?region=%s#/research?Id=%s", sechub\_region, finding\_id) as finding\_url<br />\| tourl(finding\_url, title) as title<br /><br />\| top 100 title,source,severity,compliance\_status, updated\_at, resource\_type, finding\_type, resource\_id, account\_id, finding\_provider by updated\_at|
|Cloud Infrastructure Security for AWS/Saved Searches|Creation of IAM Role|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Creation of IAM Role|\_sourceCategory={{CloudTrailLogsdatasource}}  CreateRole<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event\_name,source\_ip,user\_principal, login\_result,mfa\_used,event\_source,aws\_region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,acc\_id,error\_message nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user\_name<br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where aws\_region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where event\_name matches("\*CreateRole\*")<br />\| formatDate(toLong(\_messageTime), "MM-dd-yyyy HH:mm:ss") as event\_time<br />\| count by user\_name,event\_source,aws\_region,event\_type,event\_category,user\_identity\_type,event\_time<br />\| top 100 user\_name,event\_source,aws\_region,event\_type,event\_category,user\_identity\_type by event\_time|
|Cloud Infrastructure Security for AWS/Saved Searches|Deleted resources over time|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Deleted resources over time|\_sourceCategory={{CloudTrailLogsdatasource}}  Delete\*<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user\_name<br />\| parse "\\"eventName\\":\\"\*\\"" as event\_name<br /> \| timeslice 1h <br /> \| parse regex field=event\_name "^(?:Delete)(?\<resource\_type\>[A-Z][A-Za-z]+)"<br /> \| count \_timeslice, resource\_type<br /> \| transpose row \_timeslice column resource\_type|
|Cloud Infrastructure Security for AWS|Disabled or Scheduled Deletion of CMK|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("DisableKey" or "ScheduleKeyDeletion")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "DisableKey" or event.action matches "ScheduleKeyDeletion"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|Disabled or Scheduled Deletion of CMKs|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  ("DisableKey" or "ScheduleKeyDeletion")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name <br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "DisableKey" or event.action matches "ScheduleKeyDeletion"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Disabled or Scheduled Deletion of CMKs|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("DisableKey" or "ScheduleKeyDeletion")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "DisableKey" or event.action matches "ScheduleKeyDeletion"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS/Saved Searches|Exposed S3 Bucket Created|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Exposed S3 Bucket Created|\_sourceCategory={{CloudTrailLogsdatasource}}  ("PutBucketAcl" or "\*FULL\_CONTROL\*")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event\_name,source\_ip,user\_principal, login\_result,mfa\_used,event\_source,aws\_region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,acc\_id,error\_message nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user\_name<br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where aws\_region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where event\_name matches("PutBucketAcl")<br />\| where permission matches("\*FULL\_CONTROL\*")<br />\| count by user\_name,user\_identity\_type,event\_source,event\_type,event\_time,aws\_region<br />\| top 100 user\_name,user\_identity\_type,event\_source,event\_type,event\_time,aws\_region by event\_time|
|Cloud Infrastructure Security for AWS|Failed Console Logins|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("ConsoleLogin" and "Failed authentication")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where (event.action matches "ConsoleLogin" and error\_message matches "Failed authentication")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|Failed Console Logins|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  ("ConsoleLogin" and "Failed authentication")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br /><br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where (event.action matches "ConsoleLogin" and error\_message matches "Failed authentication")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Failed Console Logins|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("ConsoleLogin" and "Failed authentication")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where (event.action matches "ConsoleLogin" and error\_message matches "Failed authentication")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Finding Count|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Security Control Failures - AWS Security Hub|\_sourceCategory={{SecurityHubLogsdatasource}}  <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName", "Resources[0].Details.AwsIamAccessKey.UserName" as cloud.account.id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName, user.name nodrop<br /><br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, 0, 0) as risk.static\_level<br />\| if (severity\_normalized \> 0 and severity\_normalized \<= 40, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 40 and severity\_normalized \<= 70, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 70 and severity\_normalized \<= 90, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 90 and severity\_normalized \<= 100, 3, risk.static\_level) as risk.static\_level<br /><br />\| parse field=finding\_type "\*/\*/\*" as rule.ruleset, rule.category, rule.name<br /><br />\| resource\_type as cloud.service.name<br />\| resource\_id as cloud.instance.id<br />\| sechub\_region as cloud.region<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{rule.ruleset}}" = "\*", true, rule.ruleset matches "{{rule.ruleset}}") AND if ("{{rule.author}}" = "\*", true, finding\_provider matches "{{rule.author}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{compliance\_status}}" = "\*", true, compliance\_status matches "{{compliance\_status}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{rule.category}}" = "\*", true, rule.category matches "{{rule.category}}")<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| count (finding\_id)|
|Cloud Infrastructure Security for AWS|Findings by Category|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Security Control Failures - AWS Security Hub|\_sourceCategory={{SecurityHubLogsdatasource}}  <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName", "Resources[0].Details.AwsIamAccessKey.UserName" as cloud.account.id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName, user.name nodrop<br /><br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, 0, 0) as risk.static\_level<br />\| if (severity\_normalized \> 0 and severity\_normalized \<= 40, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 40 and severity\_normalized \<= 70, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 70 and severity\_normalized \<= 90, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 90 and severity\_normalized \<= 100, 3, risk.static\_level) as risk.static\_level<br /><br />\| parse field=finding\_type "\*/\*/\*" as rule.ruleset, rule.category, rule.name<br /><br />\| resource\_type as cloud.service.name<br />\| resource\_id as cloud.instance.id<br />\| sechub\_region as cloud.region<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{rule.ruleset}}" = "\*", true, rule.ruleset matches "{{rule.ruleset}}") AND if ("{{rule.author}}" = "\*", true, finding\_provider matches "{{rule.author}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{compliance\_status}}" = "\*", true, compliance\_status matches "{{compliance\_status}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{rule.category}}" = "\*", true, rule.category matches "{{rule.category}}")<br /><br />\| count(finding\_id) by rule.category<br />\| sort by \_count|
|Cloud Infrastructure Security for AWS|Findings by Resource|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Security Control Failures - AWS Security Hub|\_sourceCategory={{SecurityHubLogsdatasource}}  <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName", "Resources[0].Details.AwsIamAccessKey.UserName" as cloud.account.id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName, user.name nodrop<br /><br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, 0, 0) as risk.static\_level<br />\| if (severity\_normalized \> 0 and severity\_normalized \<= 40, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 40 and severity\_normalized \<= 70, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 70 and severity\_normalized \<= 90, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 90 and severity\_normalized \<= 100, 3, risk.static\_level) as risk.static\_level<br /><br />\| parse field=finding\_type "\*/\*/\*" as rule.ruleset, rule.category, rule.name<br /><br />\| resource\_type as cloud.service.name<br />\| resource\_id as cloud.instance.id<br />\| sechub\_region as cloud.region<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{rule.ruleset}}" = "\*", true, rule.ruleset matches "{{rule.ruleset}}") AND if ("{{rule.author}}" = "\*", true, finding\_provider matches "{{rule.author}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{compliance\_status}}" = "\*", true, compliance\_status matches "{{compliance\_status}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{rule.category}}" = "\*", true, rule.category matches "{{rule.category}}")<br /><br />\| count by cloud.instance.id, user.name, cloud.region, cloud.account.id<br />\| sort by \_count|
|Cloud Infrastructure Security for AWS|Findings by Resource Type|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Security Control Failures - AWS Security Hub|\_sourceCategory={{SecurityHubLogsdatasource}}  <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName", "Resources[0].Details.AwsIamAccessKey.UserName" as cloud.account.id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName, user.name nodrop<br /><br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, 0, 0) as risk.static\_level<br />\| if (severity\_normalized \> 0 and severity\_normalized \<= 40, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 40 and severity\_normalized \<= 70, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 70 and severity\_normalized \<= 90, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 90 and severity\_normalized \<= 100, 3, risk.static\_level) as risk.static\_level<br /><br />\| parse field=finding\_type "\*/\*/\*" as rule.ruleset, rule.category, rule.name<br /><br />\| resource\_type as cloud.service.name<br />\| resource\_id as cloud.instance.id<br />\| sechub\_region as cloud.region<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{rule.ruleset}}" = "\*", true, rule.ruleset matches "{{rule.ruleset}}") AND if ("{{rule.author}}" = "\*", true, finding\_provider matches "{{rule.author}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{compliance\_status}}" = "\*", true, compliance\_status matches "{{compliance\_status}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{rule.category}}" = "\*", true, rule.category matches "{{rule.category}}")<br /><br />\| count by cloud.service.name<br />\| sort by \_count|
|Cloud Infrastructure Security for AWS|Findings Trend|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Security Control Failures - AWS Security Hub|\_sourceCategory={{SecurityHubLogsdatasource}}  <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName", "Resources[0].Details.AwsIamAccessKey.UserName" as cloud.account.id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName, user.name nodrop<br /><br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, 0, 0) as risk.static\_level<br />\| if (severity\_normalized \> 0 and severity\_normalized \<= 40, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 40 and severity\_normalized \<= 70, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 70 and severity\_normalized \<= 90, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 90 and severity\_normalized \<= 100, 3, risk.static\_level) as risk.static\_level<br /><br />\| parse field=finding\_type "\*/\*/\*" as rule.ruleset, rule.category, rule.name<br /><br />\| resource\_type as cloud.service.name<br />\| resource\_id as cloud.instance.id<br />\| sechub\_region as cloud.region<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{rule.ruleset}}" = "\*", true, rule.ruleset matches "{{rule.ruleset}}") AND if ("{{rule.author}}" = "\*", true, finding\_provider matches "{{rule.author}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{compliance\_status}}" = "\*", true, compliance\_status matches "{{compliance\_status}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{rule.category}}" = "\*", true, rule.category matches "{{rule.category}}")<br /> <br />\| timeslice 1d<br />\| count(finding\_id) by \_timeslice|
|Cloud Infrastructure Security for AWS|Gateway Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateCustomerGateway" or "DeleteCustomerGateway" or "AttachInternetGateway" or "CreateInternetGateway" or "DeleteInternetGateway" or "DetachInternetGateway")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name <br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateCustomerGateway" or event.action matches "DeleteCustomerGateway" or event.action matches "AttachInternetGateway" or event.action matches "CreateInternetGateway" or event.action matches "DeleteInternetGateway" or event.action matches "DetachInternetGateway"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS/Saved Searches|Gateway Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Gateway Changes|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateCustomerGateway" or "DeleteCustomerGateway" or "AttachInternetGateway" or "CreateInternetGateway" or "DeleteInternetGateway" or "DetachInternetGateway")<br />\| json "requestID","eventID","userIdentity.accountId","sourceIPAddress","awsRegion","eventName","eventType" as request\_id, event\_id,acc\_id,source\_ip,region,event\_name,event\_type nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user\_name<br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where eventName matches "CreateCustomerGateway" or eventName matches "DeleteCustomerGateway" or eventName matches "AttachInternetGateway" or eventName matches "CreateInternetGateway" or eventName matches "DeleteInternetGateway" or eventName matches "DetachInternetGateway"<br />\| count as frequency by user\_name,acc\_id<br />\| sort by frequency<br />\| limit 100|
|Cloud Infrastructure Security for AWS|Gateway Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateCustomerGateway" or "DeleteCustomerGateway" or "AttachInternetGateway" or "CreateInternetGateway" or "DeleteInternetGateway" or "DetachInternetGateway")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateCustomerGateway" or event.action matches "DeleteCustomerGateway" or event.action matches "AttachInternetGateway" or event.action matches "CreateInternetGateway" or event.action matches "DeleteInternetGateway" or event.action matches "DetachInternetGateway"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|Gateway Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateCustomerGateway" or "DeleteCustomerGateway" or "AttachInternetGateway" or "CreateInternetGateway" or "DeleteInternetGateway" or "DetachInternetGateway")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateCustomerGateway" or event.action matches "DeleteCustomerGateway" or event.action matches "AttachInternetGateway" or event.action matches "CreateInternetGateway" or event.action matches "DeleteInternetGateway" or event.action matches "DetachInternetGateway"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|IAM Policy Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  <br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("Add\*") or event.action matches("Attach\*") or event.action matches("Change\*") or event.action matches("Create\*") or event.action matches("Deactivate\*") or event.action matches("Delete\*") or event.action matches("Detach\*") or event.action matches("Enable\*") or event.action matches("Put\*") or event.action matches("Remove\*") or event.action matches("Set\*") or event.action matches("Update\*") or event.action matches("Upload\*")<br />\| where cloud.service.name matches("\*iam\*")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|IAM Policy Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  <br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("Add\*") or event.action matches("Attach\*") or event.action matches("Change\*") or event.action matches("Create\*") or event.action matches("Deactivate\*") or event.action matches("Delete\*") or event.action matches("Detach\*") or event.action matches("Enable\*") or event.action matches("Put\*") or event.action matches("Remove\*") or event.action matches("Set\*") or event.action matches("Update\*") or event.action matches("Upload\*")<br />\| where cloud.service.name matches("\*iam\*")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|IAM Policy Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  <br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name <br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("Add\*") or event.action matches("Attach\*") or event.action matches("Change\*") or event.action matches("Create\*") or event.action matches("Deactivate\*") or event.action matches("Delete\*") or event.action matches("Detach\*") or event.action matches("Enable\*") or event.action matches("Put\*") or event.action matches("Remove\*") or event.action matches("Set\*") or event.action matches("Update\*") or event.action matches("Upload\*")<br />\| where cloud.service.name matches("\*iam\*")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS/Saved Searches|IAM Policy Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/IAM Policy Changes|\_sourceCategory={{CloudTrailLogsdatasource}} <br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event\_name,source\_ip,user\_principal, login\_result,mfa\_used,event\_source,aws\_region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,acc\_id,error\_message nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user\_name<br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where aws\_region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where event\_name matches("Add\*") or event\_name matches("Attach\*") or event\_name matches("Change\*") or event\_name matches("Create\*") or event\_name matches("Deactivate\*") or event\_name matches("Delete\*") or event\_name matches("Detach\*") or event\_name matches("Enable\*") or event\_name matches("Put\*") or event\_name matches("Remove\*") or event\_name matches("Set\*") or event\_name matches("Update\*") or event\_name matches("Upload\*")<br />\| where event\_source matches("\*iam.amazonaws.com\*")<br />\| count by user\_name,acc\_id,user\_identity\_type,event\_source,event\_type,event\_time,event\_name,aws\_region<br />\| top 100 user\_name,acc\_id,user\_identity\_type,event\_source,event\_type,event\_time,event\_name,aws\_region by event\_time|
|Cloud Infrastructure Security for AWS|Impossible Travel Events|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity|\_sourceCategory={{CloudTrailLogsdatasource}} <br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />// filter and sort the data<br />\| where isValidIPv4(client.ip) or isValidIPv6(client.ip)<br />\| where !isNull(client.ip)<br />\| if(isValidIPv4(client.ip), if(!isPrivateIP(client.ip),true,false),true) as is\_public<br />\| where is\_public<br />\| where !isNull(user.name)<br /><br />\| min(\_messagetime) AS login\_time BY user.name,client.ip<br />\| sort by user.name, +login\_time<br />//\| Next, find the previous IP address where each user logged in from, and the previous login time.<br />\| ipv4ToNumber(client.ip) AS ip\_decimal<br />\| backshift ip\_decimal BY user.name<br />\| backshift login\_time AS previous\_login<br />\| where !(isNull(\_backshift))<br />//\| Next, we?ll convert the IP addresses that are in a decimal format to the standard IP address using octets.<br />\| toInt(floor(\_backshift/pow(256, 3))) AS octet1<br />\| toInt(floor((\_backshift-octet1\*pow(256, 3))/pow(256, 2))) AS octet2<br />\| toInt(floor((\_backshift-(octet1\*pow(256, 3)+octet2\*pow(256, 2)))/256)) AS octet3<br />\| toInt(\_backshift-(octet1\*pow(256, 3)+octet2\*pow(256, 2)+octet3\*256)) AS octet4<br />\| concat(octet1,".",octet2,".",octet3,".",octet4) AS previous\_ip<br />//\| Now that we have two different IP addresses, we can use geo lookup on both to find our where each occurred.<br />\| lookup latitude AS lat1, longitude AS long1, country\_name AS country\_name1 FROM geo://location ON ip=client.ip<br />\| lookup latitude AS lat2, longitude AS long2, country\_name AS country\_name2 FROM geo://location ON ip=previous\_ip<br />//\| Now that we have two geolocations from two successive logins, we can calculate the distance between them using the Haversine function<br />\| haversine(lat1, long1, lat2, long2) AS distance\_kms<br />//\| Calculate the speed someone would need to travel that distance in the time between the two logins<br />\| (login\_time - previous\_login)/3600000 AS login\_time\_delta\_hrs<br />\| where login\_time\_delta\_hrs \> 0<br />\| distance\_kms/login\_time\_delta\_hrs AS apparent\_velocity\_kph<br />\| where apparent\_velocity\_kph \> 0<br />//\| Flag certain speeds as suspicious.<br />\| 500 AS suspicious\_speed<br />\| where apparent\_velocity\_kph \> suspicious\_speed<br />//\| add some formatting to clean up the results and make them more human-readable. Add these lines to your query:<br />\| concat(client.ip,", ",previous\_ip) AS ip\_addresses<br />\| if(country\_name1 \<\> country\_name2, concat(country\_name1, ", ", country\_name2), country\_name1) AS countries<br />\| where apparent\_velocity\_kph != "Infinity"<br /><br />\| sort by apparent\_velocity\_kph<br />\| fields user.name, ip\_addresses, countries, distance\_kms, login\_time\_delta\_hrs<br />\| max(distance\_kms) as distance by user.name, ip\_addresses, countries, login\_time\_delta\_hrs<br />\| sort by distance desc|
|Cloud Infrastructure Security for AWS|Impossible Travel Events|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity|\_sourceCategory={{CloudTrailLogsdatasource}} <br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />// filter and sort the data<br />\| where isValidIPv4(client.ip) or isValidIPv6(client.ip)<br />\| where !isNull(client.ip)<br />\| if(isValidIPv4(client.ip), if(!isPrivateIP(client.ip),true,false),true) as is\_public<br />\| where is\_public<br />\| where !isNull(user.name)<br /><br />\| min(\_messagetime) AS login\_time BY user.name,client.ip<br />\| sort by user.name, +login\_time<br />//\| Next, find the previous IP address where each user logged in from, and the previous login time.<br />\| ipv4ToNumber(client.ip) AS ip\_decimal<br />\| backshift ip\_decimal BY user.name<br />\| backshift login\_time AS previous\_login<br />\| where !(isNull(\_backshift))<br />//\| Next, we?ll convert the IP addresses that are in a decimal format to the standard IP address using octets.<br />\| toInt(floor(\_backshift/pow(256, 3))) AS octet1<br />\| toInt(floor((\_backshift-octet1\*pow(256, 3))/pow(256, 2))) AS octet2<br />\| toInt(floor((\_backshift-(octet1\*pow(256, 3)+octet2\*pow(256, 2)))/256)) AS octet3<br />\| toInt(\_backshift-(octet1\*pow(256, 3)+octet2\*pow(256, 2)+octet3\*256)) AS octet4<br />\| concat(octet1,".",octet2,".",octet3,".",octet4) AS previous\_ip<br />//\| Now that we have two different IP addresses, we can use geo lookup on both to find our where each occurred.<br />\| lookup latitude AS lat1, longitude AS long1, country\_name AS country\_name1 FROM geo://location ON ip=client.ip<br />\| lookup latitude AS lat2, longitude AS long2, country\_name AS country\_name2 FROM geo://location ON ip=previous\_ip<br />//\| Now that we have two geolocations from two successive logins, we can calculate the distance between them using the Haversine function<br />\| haversine(lat1, long1, lat2, long2) AS distance\_kms<br />//\| Calculate the speed someone would need to travel that distance in the time between the two logins<br />\| (login\_time - previous\_login)/3600000 AS login\_time\_delta\_hrs<br />\| where login\_time\_delta\_hrs \> 0<br />\| distance\_kms/login\_time\_delta\_hrs AS apparent\_velocity\_kph<br />\| where apparent\_velocity\_kph \> 0<br />//\| Flag certain speeds as suspicious.<br />\| 500 AS suspicious\_speed<br />\| where apparent\_velocity\_kph \> suspicious\_speed<br />//\| add some formatting to clean up the results and make them more human-readable. Add these lines to your query:<br />\| concat(client.ip,", ",previous\_ip) AS ip\_addresses<br />\| if(country\_name1 \<\> country\_name2, concat(country\_name1, ", ", country\_name2), country\_name1) AS countries<br />\| where apparent\_velocity\_kph != "Infinity"<br /><br />\| sort by apparent\_velocity\_kph<br />\| fields user.name, ip\_addresses, countries, distance\_kms, login\_time\_delta\_hrs<br />\| max(distance\_kms) as distance by user.name, ip\_addresses, countries, login\_time\_delta\_hrs<br />\| sort by distance desc<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Impossible Travel Events|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}} <br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name <br /><br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />// filter and sort the data<br />\| where isValidIPv4(client.ip) or isValidIPv6(client.ip)<br />\| where !isNull(client.ip)<br />\| if(isValidIPv4(client.ip), if(!isPrivateIP(client.ip),true,false),true) as is\_public<br />\| where is\_public<br />\| where !isNull(user.name)<br /><br />\| min(\_messagetime) AS login\_time BY user.name,client.ip<br />\| sort by user.name, +login\_time<br />//\| Next, find the previous IP address where each user logged in from, and the previous login time.<br />\| ipv4ToNumber(client.ip) AS ip\_decimal<br />\| backshift ip\_decimal BY user.name<br />\| backshift login\_time AS previous\_login<br />\| where !(isNull(\_backshift))<br />//\| Next, we?ll convert the IP addresses that are in a decimal format to the standard IP address using octets.<br />\| toInt(floor(\_backshift/pow(256, 3))) AS octet1<br />\| toInt(floor((\_backshift-octet1\*pow(256, 3))/pow(256, 2))) AS octet2<br />\| toInt(floor((\_backshift-(octet1\*pow(256, 3)+octet2\*pow(256, 2)))/256)) AS octet3<br />\| toInt(\_backshift-(octet1\*pow(256, 3)+octet2\*pow(256, 2)+octet3\*256)) AS octet4<br />\| concat(octet1,".",octet2,".",octet3,".",octet4) AS previous\_ip<br />//\| Now that we have two different IP addresses, we can use geo lookup on both to find our where each occurred.<br />\| lookup latitude AS lat1, longitude AS long1, country\_name AS country\_name1 FROM geo://location ON ip=client.ip<br />\| lookup latitude AS lat2, longitude AS long2, country\_name AS country\_name2 FROM geo://location ON ip=previous\_ip<br />//\| Now that we have two geolocations from two successive logins, we can calculate the distance between them using the Haversine function<br />\| haversine(lat1, long1, lat2, long2) AS distance\_kms<br />//\| Calculate the speed someone would need to travel that distance in the time between the two logins<br />\| (login\_time - previous\_login)/3600000 AS login\_time\_delta\_hrs<br />\| where login\_time\_delta\_hrs \> 0<br />\| distance\_kms/login\_time\_delta\_hrs AS apparent\_velocity\_kph<br />\| where apparent\_velocity\_kph \> 0<br />//\| Flag certain speeds as suspicious.<br />\| 500 AS suspicious\_speed<br />\| where apparent\_velocity\_kph \> suspicious\_speed<br />//\| add some formatting to clean up the results and make them more human-readable. Add these lines to your query:<br />\| concat(client.ip,", ",previous\_ip) AS ip\_addresses<br />\| if(country\_name1 \<\> country\_name2, concat(country\_name1, ", ", country\_name2), country\_name1) AS countries<br />\| where apparent\_velocity\_kph != "Infinity"<br /><br />\| sort by apparent\_velocity\_kph<br />\| fields user.name, ip\_addresses, countries, distance\_kms, login\_time\_delta\_hrs<br />\| max(distance\_kms) as distance by user.name, ip\_addresses, countries, login\_time\_delta\_hrs<br />\| sort by distance desc<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Insights - No Action Required|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight  insightupdated) <br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToResponse", "insight.timeToDetection" ,"insight.timeToRemediation","insight.assignee", "operator.email",  "insight.status", "insight.resolution", "insight.severity", "insight.closed", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.description",  "insight.name", "insight.readableId", "insight.id"  as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time, insight\_time\_to\_response , insight\_time\_to\_detection, insight\_time\_to\_remediation , insight\_assignee , operator\_email, insight\_status, insight\_resolution, insight\_severity, insight\_closedAt, insight\_source, entity\_value, entity\_type, entity\_id, insight\_description, insight\_name, insight\_readableId, insight\_Id nodrop<br />\| where insight\_status = "closed"<br />\| where insight\_resolution = "No Action"<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where  (risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />\| replace(insight\_tags, "[","") as insight\_tags<br />\| replace(insight\_tags, "]","") as insight\_tags<br />\| replace(insight\_tags, "\\"","") as insight\_tags<br />\| replace(insight\_tags, ","," \| ") as insight\_tags<br />\| replace(insight\_ruleId, "[","") as insight\_ruleId<br />\| replace(insight\_ruleId, "]","") as insight\_ruleId<br />\| replace(insight\_ruleId, "\\"","") as insight\_ruleId<br />\| replace(insight\_ruleId, ","," \| ") as insight\_ruleId<br />\| count|
|Cloud Infrastructure Security for AWS|Insights by Assignee|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight ) or (\_index=sumologic\_system\_events \_sourcecategory=cseinsight ) <br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToResponse", "insight.timeToDetection" ,"insight.timeToRemediation","insight.assignee", "operator.email",  "insight.status", "insight.resolution", "insight.severity", "insight.closed", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.description",  "insight.name", "insight.readableId", "insight.id"  as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time, insight\_time\_to\_response , insight\_time\_to\_detection, insight\_time\_to\_remediation , insight\_assignee , operator\_email, insight\_status, insight\_resolution, insight\_severity, insight\_closedAt, insight\_source, entity\_value, entity\_type, entity\_id, insight\_description, insight\_name, insight\_readableId, insight\_Id nodrop<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where  (risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />\| if(isBlank(insight\_assignee), "Unassigned", insight\_assignee) as insight\_assignee<br />\| count\_distinct(insight\_Id) by insight\_assignee<br />\| sort by \_count\_distinct desc<br />|
|Cloud Infrastructure Security for AWS|Insights by Created vs Closed|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight  insightcreated) OR <br />(\_index=sumologic\_system\_events \_sourcecategory=cseinsight  insightcreated)<br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToDetection" ,"insight.assignee", "operator.email",  "insight.status", "insight.severity", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.entitySensorZone" ,"insight.description",  "insight.name", "insight.readableId", "insight.id",  "insight.confidence"  as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time , insight\_time\_to\_detection , insight\_assignee , operator\_email, insight\_status, insight\_severity, insight\_source, entity\_value, entity\_type, entity\_id, entity\_sensor\_zone ,insight\_description, insight\_name, insight\_readableId, insight\_Id, insight\_confidence nodrop<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where  (risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />\| json field=\_raw "insight.signals.length()" as signal\_count<br />\| replace(insight\_tags, "[","") as insight\_tags<br />\| replace(insight\_tags, "]","") as insight\_tags<br />\| replace(insight\_tags, "\\"","") as insight\_tags<br />\| replace(insight\_tags, ","," \| ") as insight\_tags<br />\| replace(insight\_ruleId, "[","") as insight\_ruleId<br />\| replace(insight\_ruleId, "]","") as insight\_ruleId<br />\| replace(insight\_ruleId, "\\"","") as insight\_ruleId<br />\| replace(insight\_ruleId, ","," \| ") as insight\_ruleId<br />\| timeslice 1d<br />\| count by \_timeslice <br />\| fillmissing timeslice<br />\| sort by \_timeslice<br /><br />|
|Cloud Infrastructure Security for AWS|Insights by Entity Type|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight ) or (\_index=sumologic\_system\_events \_sourcecategory=cseinsight ) <br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToResponse", "insight.timeToDetection" ,"insight.timeToRemediation","insight.assignee", "operator.email",  "insight.status", "insight.resolution", "insight.severity", "insight.closed", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.description",  "insight.name", "insight.readableId", "insight.id"  as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time, insight\_time\_to\_response , insight\_time\_to\_detection, insight\_time\_to\_remediation , insight\_assignee , operator\_email, insight\_status, insight\_resolution, insight\_severity, insight\_closedAt, insight\_source, entity\_value, entity\_type, entity\_id, insight\_description, insight\_name, insight\_readableId, insight\_Id nodrop<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where  (risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />\| count\_distinct(insight\_Id) by entity\_type<br />\| sort by \_count\_distinct desc<br />|
|Cloud Infrastructure Security for AWS|Insights by Resource|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight ) or (\_index=sumologic\_system\_events \_sourcecategory=cseinsight ) <br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToResponse", "insight.timeToDetection" ,"insight.timeToRemediation","insight.assignee", "operator.email",  "insight.status", "insight.resolution", "insight.severity", "insight.closed", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.description",  "insight.name", "insight.readableId", "insight.id"  as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time, insight\_time\_to\_response , insight\_time\_to\_detection, insight\_time\_to\_remediation , insight\_assignee , operator\_email, insight\_status, insight\_resolution, insight\_severity, insight\_closedAt, insight\_source, entity\_value, entity\_type, entity\_id, insight\_description, insight\_name, insight\_readableId, insight\_Id nodrop<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where  (risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />\| count\_distinct(insight\_Id) by entity\_value, entity\_type, risk.static\_level<br />\| sort by \_count\_distinct desc<br />|
|Cloud Infrastructure Security for AWS|Insights by Rule ID, and Insight Name|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight ) or (\_index=sumologic\_system\_events \_sourcecategory=cseinsight )<br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToResponse", "insight.timeToDetection" ,"insight.timeToRemediation","insight.assignee", "operator.email",  "insight.status", "insight.resolution", "insight.severity", "insight.closed", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.description",  "insight.name", "insight.readableId", "insight.id"  as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time, insight\_time\_to\_response , insight\_time\_to\_detection, insight\_time\_to\_remediation , insight\_assignee , operator\_email, insight\_status, insight\_resolution, insight\_severity, insight\_closedAt, insight\_source, entity\_value, entity\_type, entity\_id, insight\_description, insight\_name, insight\_readableId, insight\_Id nodrop<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where  (risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />\| replace(insight\_tags, "[","") as insight\_tags<br />\| replace(insight\_tags, "]"," ") as insight\_tags<br />\| replace(insight\_tags, "\\"","") as insight\_tags<br />\| replace(insight\_tags, ","," \| ") as insight\_tags<br />\| replace(insight\_ruleId, "[","") as insight\_ruleId<br />\| replace(insight\_ruleId, "]"," ") as insight\_ruleId<br />\| replace(insight\_ruleId, "\\"","") as insight\_ruleId<br />\| replace(insight\_ruleId, ","," \| ") as insight\_ruleId<br />\| parse regex field=insight\_ruleId "(?\<ruleID\>[A-Z0-9-]+)" multi<br />\| count\_distinct(insight\_Id)  by ruleID, insight\_name<br />\| sort by \_count\_distinct desc<br />|
|Cloud Infrastructure Security for AWS|Insights by Status|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight ) or (\_index=sumologic\_system\_events \_sourcecategory=cseinsight ) <br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToResponse", "insight.timeToDetection" ,"insight.timeToRemediation","insight.assignee", "operator.email",  "insight.status", "insight.resolution", "insight.severity", "insight.closed", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.description",  "insight.name", "insight.readableId", "insight.id"  as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time, insight\_time\_to\_response , insight\_time\_to\_detection, insight\_time\_to\_remediation , insight\_assignee , operator\_email, insight\_status, insight\_resolution, insight\_severity, insight\_closedAt, insight\_source, entity\_value, entity\_type, entity\_id, insight\_description, insight\_name, insight\_readableId, insight\_Id nodrop<br />\| where insight\_status in ("new","closed","inprogress")<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where  (risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />\| count\_distinct(insight\_Id) by insight\_status<br />\| sort by \_count\_distinct desc<br />|
|Cloud Infrastructure Security for AWS|Insights by Tag|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight ) or (\_index=sumologic\_system\_events \_sourcecategory=cseinsight )<br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToResponse", "insight.timeToDetection" ,"insight.timeToRemediation","insight.assignee", "operator.email",  "insight.status", "insight.resolution", "insight.severity", "insight.closed", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.description",  "insight.name", "insight.readableId", "insight.id"  as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time, insight\_time\_to\_response , insight\_time\_to\_detection, insight\_time\_to\_remediation , insight\_assignee , operator\_email, insight\_status, insight\_resolution, insight\_severity, insight\_closedAt, insight\_source, entity\_value, entity\_type, entity\_id, insight\_description, insight\_name, insight\_readableId, insight\_Id nodrop<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where  (risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />\| replace(insight\_tags, "[","") as insight\_tags<br />\| replace(insight\_tags, "]"," ") as insight\_tags<br />\| replace(insight\_tags, "\\"","") as insight\_tags<br />\| replace(insight\_tags, ","," \| ") as insight\_tags<br />\| replace(insight\_ruleId, "[","") as insight\_ruleId<br />\| replace(insight\_ruleId, "]"," ") as insight\_ruleId<br />\| replace(insight\_ruleId, "\\"","") as insight\_ruleId<br />\| replace(insight\_ruleId, ","," \| ") as insight\_ruleId<br />\| parse regex field=insight\_tags "(?\<tag\>[\\w-\_ :.]+)" multi<br />\| count\_distinct(insight\_Id) by tag, insight\_name<br />\| sort by \_count\_distinct desc|
|Cloud Infrastructure Security for AWS|Insights Closed|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight  insightupdated) <br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToResponse", "insight.timeToDetection" ,"insight.timeToRemediation","insight.assignee", "operator.email",  "insight.status", "insight.resolution", "insight.severity", "insight.closed", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.description",  "insight.name", "insight.readableId", "insight.id"  as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time, insight\_time\_to\_response , insight\_time\_to\_detection, insight\_time\_to\_remediation , insight\_assignee , operator\_email, insight\_status, insight\_resolution, insight\_severity, insight\_closedAt, insight\_source, entity\_value, entity\_type, entity\_id, insight\_description, insight\_name, insight\_readableId, insight\_Id nodrop<br />\| where insight\_status = "closed"<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where  (risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />\| replace(insight\_tags, "[","") as insight\_tags<br />\| replace(insight\_tags, "]","") as insight\_tags<br />\| replace(insight\_tags, "\\"","") as insight\_tags<br />\| replace(insight\_tags, ","," \| ") as insight\_tags<br />\| replace(insight\_ruleId, "[","") as insight\_ruleId<br />\| replace(insight\_ruleId, "]","") as insight\_ruleId<br />\| replace(insight\_ruleId, "\\"","") as insight\_ruleId<br />\| replace(insight\_ruleId, ","," \| ") as insight\_ruleId<br />\| count|
|Cloud Infrastructure Security for AWS|Insights Created|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight  insightcreated) OR <br />(\_index=sumologic\_system\_events \_sourcecategory=cseinsight  insightcreated)<br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToDetection" ,"insight.assignee", "operator.email",  "insight.status", "insight.severity", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.entitySensorZone" ,"insight.description",  "insight.name", "insight.readableId", "insight.id",  "insight.confidence"  as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time , insight\_time\_to\_detection , insight\_assignee , operator\_email, insight\_status, insight\_severity, insight\_source, entity\_value, entity\_type, entity\_id, entity\_sensor\_zone ,insight\_description, insight\_name, insight\_readableId, insight\_Id, insight\_confidence nodrop<br />\| json field=\_raw "insight.signals.length()" as signal\_count<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where  (risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />\| replace(insight\_tags, "[","") as insight\_tags<br />\| replace(insight\_tags, "]","") as insight\_tags<br />\| replace(insight\_tags, "\\"","") as insight\_tags<br />\| replace(insight\_tags, ","," \| ") as insight\_tags<br />\| replace(insight\_ruleId, "[","") as insight\_ruleId<br />\| replace(insight\_ruleId, "]","") as insight\_ruleId<br />\| replace(insight\_ruleId, "\\"","") as insight\_ruleId<br />\| replace(insight\_ruleId, ","," \| ") as insight\_ruleId<br />\| count|
|Cloud Infrastructure Security for AWS|Insights Created - Outlier|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight  insightcreated) OR <br />(\_index=sumologic\_system\_events \_sourcecategory=cseinsight  insightcreated)<br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToDetection" ,"insight.assignee", "operator.email",  "insight.status", "insight.severity", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.entitySensorZone" ,"insight.description",  "insight.name", "insight.readableId", "insight.id",  "insight.confidence"  as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time , insight\_time\_to\_detection , insight\_assignee , operator\_email, insight\_status, insight\_severity, insight\_source, entity\_value, entity\_type, entity\_id, entity\_sensor\_zone ,insight\_description, insight\_name, insight\_readableId, insight\_Id, insight\_confidence nodrop<br />\| json field=\_raw "insight.signals.length()" as signal\_count<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where  (risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />\| replace(insight\_tags, "[","") as insight\_tags<br />\| replace(insight\_tags, "]","") as insight\_tags<br />\| replace(insight\_tags, "\\"","") as insight\_tags<br />\| replace(insight\_tags, ","," \| ") as insight\_tags<br />\| replace(insight\_ruleId, "[","") as insight\_ruleId<br />\| replace(insight\_ruleId, "]","") as insight\_ruleId<br />\| replace(insight\_ruleId, "\\"","") as insight\_ruleId<br />\| replace(insight\_ruleId, ","," \| ") as insight\_ruleId<br />\| timeslice 1d<br />\| count by \_timeslice <br />\| fillmissing timeslice<br />\| sort by \_timeslice<br />\| outlier \_count window=10,threshold=3,consecutive=2,direction=+|
|Cloud Infrastructure Security for AWS|Insights Duplicates|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight  insightupdated) <br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToResponse", "insight.timeToDetection" ,"insight.timeToRemediation","insight.assignee", "operator.email",  "insight.status", "insight.resolution", "insight.severity", "insight.closed", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.description",  "insight.name", "insight.readableId", "insight.id"  as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time, insight\_time\_to\_response , insight\_time\_to\_detection, insight\_time\_to\_remediation , insight\_assignee , operator\_email, insight\_status, insight\_resolution, insight\_severity, insight\_closedAt, insight\_source, entity\_value, entity\_type, entity\_id, insight\_description, insight\_name, insight\_readableId, insight\_Id nodrop<br />\| where insight\_status = "closed"<br />\| where insight\_resolution = "Duplicate"<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where  (risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />\| replace(insight\_tags, "[","") as insight\_tags<br />\| replace(insight\_tags, "]","") as insight\_tags<br />\| replace(insight\_tags, "\\"","") as insight\_tags<br />\| replace(insight\_tags, ","," \| ") as insight\_tags<br />\| replace(insight\_ruleId, "[","") as insight\_ruleId<br />\| replace(insight\_ruleId, "]","") as insight\_ruleId<br />\| replace(insight\_ruleId, "\\"","") as insight\_ruleId<br />\| replace(insight\_ruleId, ","," \| ") as insight\_ruleId<br />\| count|
|Cloud Infrastructure Security for AWS|Insights False Positives|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight  insightupdated) <br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToResponse", "insight.timeToDetection" ,"insight.timeToRemediation","insight.assignee", "operator.email",  "insight.status", "insight.resolution", "insight.severity", "insight.closed", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.description",  "insight.name", "insight.readableId", "insight.id"  as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time, insight\_time\_to\_response , insight\_time\_to\_detection, insight\_time\_to\_remediation , insight\_assignee , operator\_email, insight\_status, insight\_resolution, insight\_severity, insight\_closedAt, insight\_source, entity\_value, entity\_type, entity\_id, insight\_description, insight\_name, insight\_readableId, insight\_Id nodrop<br />\| where insight\_status = "closed"<br />\| where insight\_resolution = "False Positive"<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where  (risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />\| replace(insight\_tags, "[","") as insight\_tags<br />\| replace(insight\_tags, "]","") as insight\_tags<br />\| replace(insight\_tags, "\\"","") as insight\_tags<br />\| replace(insight\_tags, ","," \| ") as insight\_tags<br />\| replace(insight\_ruleId, "[","") as insight\_ruleId<br />\| replace(insight\_ruleId, "]","") as insight\_ruleId<br />\| replace(insight\_ruleId, "\\"","") as insight\_ruleId<br />\| replace(insight\_ruleId, ","," \| ") as insight\_ruleId<br />\| count|
|Cloud Infrastructure Security for AWS/Saved Searches|Least Common Out of Compliance Findings|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Least Common Out of Compliance Findings|\_sourceCategory={{SecurityHubLogsdatasource}}  <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName" as account\_id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName nodrop<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, "Informational", "Others") as severity<br />\| if (severity\_normalized \<= 39, "Low", severity) as severity<br />\| if ((severity\_normalized \<= 69) and (severity\_normalized \>= 40), "Medium", severity) as severity<br />\| if ((severity\_normalized \<= 89) and (severity\_normalized \>= 70), "High", severity) as severity<br />\| if (severity\_normalized \<= 100 and severity\_normalized \>= 90, "Critical", severity) as severity<br /><br />// global filters<br />\| where account\_id matches "\*"<br />\| where finding\_id matches "\*"<br />\| where finding\_type matches "\*"<br />\| where finding\_provider matches "\*"<br />\| where severity matches "\*"<br />\| where compliance\_status matches "\*"<br /><br />\| where !isBlank(compliance\_status) and compliance\_status matches "FAILED"<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| timeslice 1h<br />\| count as frequency by finding\_type<br />\| sort by frequency asc<br />\| limit 50|
|Cloud Infrastructure Security for AWS/Saved Searches|Most Common Out of Compliance Findings|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Most Common Out of Compliance Findings|\_sourceCategory={{SecurityHubLogsdatasource}}  <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName" as account\_id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName nodrop<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, "Informational", "Others") as severity<br />\| if (severity\_normalized \<= 39, "Low", severity) as severity<br />\| if ((severity\_normalized \<= 69) and (severity\_normalized \>= 40), "Medium", severity) as severity<br />\| if ((severity\_normalized \<= 89) and (severity\_normalized \>= 70), "High", severity) as severity<br />\| if (severity\_normalized \<= 100 and severity\_normalized \>= 90, "Critical", severity) as severity<br /><br />// global filters<br />\| where account\_id matches "\*"<br />\| where finding\_id matches "\*"<br />\| where finding\_type matches "\*"<br />\| where finding\_provider matches "\*"<br />\| where severity matches "\*"<br />\| where compliance\_status matches "\*"<br /><br />\| where !isBlank(compliance\_status) and compliance\_status matches "FAILED"<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| timeslice 1h<br />\| count as frequency by finding\_type<br />\| sort by frequency<br />\| limit 50|
|Cloud Infrastructure Security for AWS|Network ACL Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateNetworkAcl" or "CreateNetworkAclEntry" or "DeleteNetworkAcl" or "DeleteNetworkAclEntry" or "ReplaceNetworkAclEntry" or "ReplaceNetworkAclAssociation")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateNetworkAcl" or event.action matches "CreateNetworkAclEntry" or event.action matches "DeleteNetworkAcl" or event.action matches "DeleteNetworkAclEntry" or event.action matches "ReplaceNetworkAclEntry" or event.action matches "ReplaceNetworkAclAssociation"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|Network ACL Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateNetworkAcl" or "CreateNetworkAclEntry" or "DeleteNetworkAcl" or "DeleteNetworkAclEntry" or "ReplaceNetworkAclEntry" or "ReplaceNetworkAclAssociation")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name <br /><br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateNetworkAcl" or event.action matches "CreateNetworkAclEntry" or event.action matches "DeleteNetworkAcl" or event.action matches "DeleteNetworkAclEntry" or event.action matches "ReplaceNetworkAclEntry" or event.action matches "ReplaceNetworkAclAssociation"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS/Saved Searches|Network ACL Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Network ACL Changes|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateNetworkAcl" or "CreateNetworkAclEntry" or "DeleteNetworkAcl" or "DeleteNetworkAclEntry" or "ReplaceNetworkAclEntry" or "ReplaceNetworkAclAssociation")<br />\| json "requestID","eventID","userIdentity.accountId","sourceIPAddress","awsRegion","eventName","eventType" as request\_id, event\_id,acc\_id,source\_ip,region,event\_name,event\_type nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user\_name <br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where eventName matches "CreateNetworkAcl" or eventName matches "CreateNetworkAclEntry" or eventName matches "DeleteNetworkAcl" or eventName matches "DeleteNetworkAclEntry" or eventName matches "ReplaceNetworkAclEntry" or eventName matches "ReplaceNetworkAclAssociation"<br />\| count as frequency by user\_name,acc\_id<br />\| sort by frequency<br />\| limit 100|
|Cloud Infrastructure Security for AWS|Network ACL Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateNetworkAcl" or "CreateNetworkAclEntry" or "DeleteNetworkAcl" or "DeleteNetworkAclEntry" or "ReplaceNetworkAclEntry" or "ReplaceNetworkAclAssociation")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateNetworkAcl" or event.action matches "CreateNetworkAclEntry" or event.action matches "DeleteNetworkAcl" or event.action matches "DeleteNetworkAclEntry" or event.action matches "ReplaceNetworkAclEntry" or event.action matches "ReplaceNetworkAclAssociation"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS/Saved Searches|New Admins Added|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/New Admins Added|\_sourceCategory={{CloudTrailLogsdatasource}} <br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage","requestParameters.policyArn","requestParameters.groupName" as event\_name,source\_ip,user\_principal, login\_result,mfa\_used,event\_source,aws\_region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,acc\_id,error\_message,policy\_arn,group\_name nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user\_name <br /><br />// global filters<br />\| where aws\_region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where event\_name matches("\*AddUserToGroup\*")<br />\| where group\_name matches("\*admin\*")<br /><br />\| count by acc\_id,event\_type,event\_time,event\_source,aws\_region<br />\| sort by event\_time<br />\| limit 100<br />\| fields - \_count|
|Cloud Infrastructure Security for AWS|Permissive S3 Buckets Created|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("PutBucketAcl" or "\*FULL\_CONTROL\*")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("PutBucketAcl")<br />\| where permission matches("\*FULL\_CONTROL\*")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Permissive S3 Buckets Created|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  ("PutBucketAcl" or "\*FULL\_CONTROL\*")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name <br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("PutBucketAcl")<br />\| where permission matches("\*FULL\_CONTROL\*")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Permissive S3 Buckets Created|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("PutBucketAcl" or "\*FULL\_CONTROL\*")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("PutBucketAcl")<br />\| where permission matches("\*FULL\_CONTROL\*")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|Root Account Logins|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  "Root"<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where user\_identity\_type="Root"<br />\| where !isBlank(user.name)<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Root Account Logins|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  "Root"<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where user\_identity\_type="Root"<br />\| where !isBlank(user.name)<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|Root Account Logins|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  "Root"<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br /><br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where user\_identity\_type="Root"<br />\| where !isBlank(user.name)<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Route Table Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateRoute" or "CreateRouteTable" or "ReplaceRoute" or "ReplaceRouteTableAssociation" or "DeleteRouteTable" or "DeleteRoute" or "DisassociateRouteTable")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateRoute" or event.action matches "CreateRouteTable" or event.action matches "ReplaceRoute" or event.action matches "ReplaceRouteTableAssociation" or event.action matches "DeleteRouteTable" or event.action matches "DeleteRoute" or event.action matches "DisassociateRouteTable"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS/Saved Searches|Route Table Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Route Table Changes|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateRoute" or "CreateRouteTable" or "ReplaceRoute" or "ReplaceRouteTableAssociation" or "DeleteRouteTable" or "DeleteRoute" or "DisassociateRouteTable")<br />\| json "requestID","eventID","userIdentity.accountId","sourceIPAddress","awsRegion","eventName","eventType" as request\_id, event\_id,acc\_id,source\_ip,region,event\_name,event\_type nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user\_name <br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where eventName matches "CreateRoute" or eventName matches "CreateRouteTable" or eventName matches "ReplaceRoute" or eventName matches "ReplaceRouteTableAssociation" or eventName matches "DeleteRouteTable" or eventName matches "DeleteRoute" or eventName matches "DisassociateRouteTable"<br /><br />\| count as frequency by user\_name,acc\_id<br />\| sort by frequency<br />\| limit 100|
|Cloud Infrastructure Security for AWS|Route Table Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateRoute" or "CreateRouteTable" or "ReplaceRoute" or "ReplaceRouteTableAssociation" or "DeleteRouteTable" or "DeleteRoute" or "DisassociateRouteTable")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name <br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateRoute" or event.action matches "CreateRouteTable" or event.action matches "ReplaceRoute" or event.action matches "ReplaceRouteTableAssociation" or event.action matches "DeleteRouteTable" or event.action matches "DeleteRoute" or event.action matches "DisassociateRouteTable"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Route Table Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateRoute" or "CreateRouteTable" or "ReplaceRoute" or "ReplaceRouteTableAssociation" or "DeleteRouteTable" or "DeleteRoute" or "DisassociateRouteTable")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateRoute" or event.action matches "CreateRouteTable" or event.action matches "ReplaceRoute" or event.action matches "ReplaceRouteTableAssociation" or event.action matches "DeleteRouteTable" or event.action matches "DeleteRoute" or event.action matches "DisassociateRouteTable"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|S3 Bucket Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  (\*BucketAcl or \*BucketPolicy or \*BucketCors or \*BucketLifecycle)<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "\*BucketAcl" or event.action matches "\*BucketPolicy" or event.action matches "\*BucketCors" or event.action matches "\*BucketLifecycle"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS/Saved Searches|S3 Bucket Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/S3 Bucket Changes|\_sourceCategory={{CloudTrailLogsdatasource}}  (\*BucketAcl or \*BucketPolicy or \*BucketCors or \*BucketLifecycle)<br />\| json "requestID","eventID","userIdentity.accountId","sourceIPAddress","awsRegion","eventName","eventType" as request\_id, event\_id,acc\_id,source\_ip,region,event\_name,event\_type nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user\_name <br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where eventName matches "\*BucketAcl" or eventName matches "\*BucketPolicy" or eventName matches "\*BucketCors" or eventName matches "\*BucketLifecycle"<br />\| count as frequency by user\_name,acc\_id<br />\| sort by frequency<br />\| limit 100|
|Cloud Infrastructure Security for AWS|S3 Bucket Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  (\*BucketAcl or \*BucketPolicy or \*BucketCors or \*BucketLifecycle)<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "\*BucketAcl" or event.action matches "\*BucketPolicy" or event.action matches "\*BucketCors" or event.action matches "\*BucketLifecycle"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|S3 Bucket Permission Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  (\*BucketAcl or \*BucketPolicy or \*BucketCors or \*BucketLifecycle)<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "\*BucketAcl" or event.action matches "\*BucketPolicy" or event.action matches "\*BucketCors" or event.action matches "\*BucketLifecycle"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|Security Control Failures - AWS Security Hub|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{SecurityHubLogsdatasource}}  <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName", "Resources[0].Details.AwsIamAccessKey.UserName" as cloud.account.id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName, user.name nodrop<br /><br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, 0, 0) as risk.static\_level<br />\| if (severity\_normalized \> 0 and severity\_normalized \<= 40, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 40 and severity\_normalized \<= 70, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 70 and severity\_normalized \<= 90, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 90 and severity\_normalized \<= 100, 3, risk.static\_level) as risk.static\_level<br /><br />\| parse field=finding\_type "\*/\*/\*" as rule.ruleset, rule.category, rule.name<br /><br />\| resource\_type as cloud.service.name<br />\| resource\_id as cloud.instance.id<br />\| sechub\_region as cloud.region<br /><br />// global filters<br />\| where if("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />// client.ip,source.user filter is not applicable<br /><br />\| where compliance\_status matches "FAILED"<br />\| topk(1, updated\_at) by finding\_id<br />\| count (finding\_id)|
|Cloud Infrastructure Security for AWS/Saved Searches|Security Group Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/Security Group Changes|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateSecurityGroup" or "DeleteSecurityGroup" or "RevokeSecurityGroupEgress" or "RevokeSecurityGroupIngress")<br />\| json "requestID","eventID","userIdentity.accountId","sourceIPAddress","awsRegion","eventName","eventType" as request\_id, event\_id,acc\_id,source\_ip,region,event\_name,event\_type nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user\_name <br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where eventName matches "CreateSecurityGroup" or eventName matches "DeleteSecurityGroup" or eventName matches "RevokeSecurityGroupEgress" or eventName matches "RevokeSecurityGroupIngress"<br />\| count as frequency by user\_name,acc\_id<br />\| sort by frequency<br />\| limit 100|
|Cloud Infrastructure Security for AWS|Security Group Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateSecurityGroup" or "DeleteSecurityGroup" or "RevokeSecurityGroupEgress" or "RevokeSecurityGroupIngress")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateSecurityGroup" or event.action matches "DeleteSecurityGroup" or event.action matches "RevokeSecurityGroupEgress" or event.action matches "RevokeSecurityGroupIngress"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Security Group Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateSecurityGroup" or "DeleteSecurityGroup" or "RevokeSecurityGroupEgress" or "RevokeSecurityGroupIngress")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateSecurityGroup" or event.action matches "DeleteSecurityGroup" or event.action matches "RevokeSecurityGroupEgress" or event.action matches "RevokeSecurityGroupIngress"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|Security Group Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateSecurityGroup" or "DeleteSecurityGroup" or "RevokeSecurityGroupEgress" or "RevokeSecurityGroupIngress")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateSecurityGroup" or event.action matches "DeleteSecurityGroup" or event.action matches "RevokeSecurityGroupEgress" or event.action matches "RevokeSecurityGroupIngress"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Suspicious Blocked Destinations by Location|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity|\_sourceCategory={{NetworkFirewallLogsdatasource}}  <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "alert" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, alert nodrop<br />\| where event.type="alert"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br /><br />\| lookup latitude, longitude, country\_code, country\_name, region, city, postal\_code from geo://location on ip = client.ip<br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="blocked",1,0) as Blocked\_count<br />\| if(event.outcome="allowed",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, server.ip, client.ip, latitude, longitude, country\_code<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by server.ip, client.ip, latitude, longitude, country\_code<br />\| smooth eventCount as eventCount\_mean by server.ip, client.ip, latitude, longitude, country\_code<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by server.ip, client.ip, latitude, longitude, country\_code<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count as event\_location by latitude, longitude<br />\| sort by event\_location|
|Cloud Infrastructure Security for AWS|Suspicious Blocked Source-Destination Pairs|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity|\_sourceCategory={{NetworkFirewallLogsdatasource}}  <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "alert" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, alert nodrop<br />\| where event.type="alert"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="blocked",1,0) as Blocked\_count<br />\| if(event.outcome="allowed",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, server.ip, client.ip<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by server.ip, client.ip<br />\| smooth eventCount as eventCount\_mean by server.ip, client.ip<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by server.ip, client.ip<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|Suspicious Blocked Source-Destination Pairs|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity|\_sourceCategory={{NetworkFirewallLogsdatasource}}  <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "alert" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, alert nodrop<br />\| where event.type="alert"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="blocked",1,0) as Blocked\_count<br />\| if(event.outcome="allowed",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, server.ip, client.ip<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by server.ip, client.ip<br />\| smooth eventCount as eventCount\_mean by server.ip, client.ip<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by server.ip, client.ip<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Suspicious Blocked Source-Destination Pairs|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{NetworkFirewallLogsdatasource}}  <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "alert" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, alert nodrop<br />\| where event.type="alert"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br /><br />// filters<br />\| where if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="blocked",1,0) as Blocked\_count<br />\| if(event.outcome="allowed",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, server.ip, client.ip<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by server.ip, client.ip<br />\| smooth eventCount as eventCount\_mean by server.ip, client.ip<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by server.ip, client.ip<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Suspicious Blocked Web Requests|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Web Activity|\_sourceCategory={{WAFLogsdatasource}}  <br />\| json "httpRequest.httpMethod","httpRequest.httpVersion","httpRequest.uri","httpRequest.clientIp","httpRequest.country","action","matchingNonTerminatingRules","rateBasedRuleList","ruleGroupList","httpSourceId","httpSourceName","terminatingRuleType","terminatingRuleId","webaclId" as event.action,http\_version,url.path,client.ip,country,event.outcome,matching\_non\_terminating\_rules,rate\_based\_rule\_list,rule\_group\_list,http\_source\_id,http\_source\_name,terminating\_rule\_type,terminating\_rule\_id,webacl\_id nodrop<br /><br />\| lookup latitude, longitude, country\_code, country\_name, region, city, postal\_code from geo://location on ip = client.ip<br /><br />// global filters<br />\| where if ("{{url.path}}" = "\*", true, url.path matches "{{url.path}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{event.outcome}}" = "\*", true, event.outcome matches "{{event.outcome}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="BLOCK",1,0) as Blocked\_count<br />\| if(event.outcome="ALLOW",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, client.ip,url.path, terminating\_rule\_type,terminating\_rule\_id,event.action,http\_source\_id,http\_source\_name, latitude, longitude, country\_code<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| smooth eventCount as eventCount\_mean by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Suspicious Blocked Web Requests|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{WAFLogsdatasource}}  <br />\| json "httpRequest.httpMethod","httpRequest.httpVersion","httpRequest.uri","httpRequest.clientIp","httpRequest.country","action","matchingNonTerminatingRules","rateBasedRuleList","ruleGroupList","httpSourceId","httpSourceName","terminatingRuleType","terminatingRuleId","webaclId" as event.action,http\_version,url.path,client.ip,country,event.outcome,matching\_non\_terminating\_rules,rate\_based\_rule\_list,rule\_group\_list,http\_source\_id,http\_source\_name,terminating\_rule\_type,terminating\_rule\_id,webacl\_id nodrop<br /><br />\| lookup latitude, longitude, country\_code, country\_name, region, city, postal\_code from geo://location on ip = client.ip<br /><br />// global filters<br />\| where if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") <br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="BLOCK",1,0) as Blocked\_count<br />\| if(event.outcome="ALLOW",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, client.ip,url.path, terminating\_rule\_type,terminating\_rule\_id,event.action,http\_source\_id,http\_source\_name, latitude, longitude, country\_code<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| smooth eventCount as eventCount\_mean by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Suspicious Blocked Web Requests|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Web Activity|\_sourceCategory={{WAFLogsdatasource}}  <br />\| json "httpRequest.httpMethod","httpRequest.httpVersion","httpRequest.uri","httpRequest.clientIp","httpRequest.country","action","matchingNonTerminatingRules","rateBasedRuleList","ruleGroupList","httpSourceId","httpSourceName","terminatingRuleType","terminatingRuleId","webaclId" as event.action,http\_version,url.path,client.ip,country,event.outcome,matching\_non\_terminating\_rules,rate\_based\_rule\_list,rule\_group\_list,http\_source\_id,http\_source\_name,terminating\_rule\_type,terminating\_rule\_id,webacl\_id nodrop<br /><br />\| lookup latitude, longitude, country\_code, country\_name, region, city, postal\_code from geo://location on ip = client.ip<br /><br />// global filters<br />\| where if ("{{url.path}}" = "\*", true, url.path matches "{{url.path}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{event.outcome}}" = "\*", true, event.outcome matches "{{event.outcome}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="BLOCK",1,0) as Blocked\_count<br />\| if(event.outcome="ALLOW",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, client.ip,url.path, terminating\_rule\_type,terminating\_rule\_id,event.action,http\_source\_id,http\_source\_name, latitude, longitude, country\_code<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| smooth eventCount as eventCount\_mean by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|Suspicious Blocked Web Requests by Location|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Web Activity|\_sourceCategory={{WAFLogsdatasource}}  <br />\| json "httpRequest.httpMethod","httpRequest.httpVersion","httpRequest.uri","httpRequest.clientIp","httpRequest.country","action","matchingNonTerminatingRules","rateBasedRuleList","ruleGroupList","httpSourceId","httpSourceName","terminatingRuleType","terminatingRuleId","webaclId" as event.action,http\_version,url.path,client.ip,country,event.outcome,matching\_non\_terminating\_rules,rate\_based\_rule\_list,rule\_group\_list,http\_source\_id,http\_source\_name,terminating\_rule\_type,terminating\_rule\_id,webacl\_id nodrop<br /><br />\| lookup latitude, longitude, country\_code, country\_name, region, city, postal\_code from geo://location on ip = client.ip<br /><br />// global filters<br />\| where if ("{{url.path}}" = "\*", true, url.path matches "{{url.path}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{event.outcome}}" = "\*", true, event.outcome matches "{{event.outcome}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="BLOCK",1,0) as Blocked\_count<br />\| if(event.outcome="ALLOW",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, client.ip,url.path, terminating\_rule\_type,terminating\_rule\_id,event.action,http\_source\_id,http\_source\_name, latitude, longitude, country\_code<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| smooth eventCount as eventCount\_mean by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count as event\_location by latitude, longitude<br />\| sort by event\_location|
|Cloud Infrastructure Security for AWS|Suspicious Destinations by Traffic (Megabytes)|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity|\_sourceCategory={{NetworkFirewallLogsdatasource}}  <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "app\_proto", "netflow" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, app\_proto, netflow nodrop<br />\| where event.type="netflow"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br />\| json field=netflow "bytes", "pkts" as network.bytes, packets nodrop<br /><br />\| lookup latitude, longitude, country\_code, country\_name, region, city, postal\_code from geo://location on ip = client.ip <br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| network.bytes/1Mi as m\_bytes<br />\| sum(m\_bytes) as total\_mega\_bytes by \_timeslice, server.ip, client.ip, latitude, longitude, country\_code<br />\| total\_mega\_bytes as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by server.ip, client.ip, latitude, longitude, country\_code<br />\| smooth eventCount as eventCount\_mean by server.ip, client.ip, latitude, longitude, country\_code <br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by server.ip, client.ip, latitude, longitude, country\_code<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count as event\_location by latitude, longitude<br />\| sort by event\_location|
|Cloud Infrastructure Security for AWS|Suspicious Megabytes Source-Destination Pairs|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity|\_sourceCategory={{NetworkFirewallLogsdatasource}}  <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "app\_proto", "netflow" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, app\_proto, netflow nodrop<br />\| where event.type="netflow"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br />\| json field=netflow "bytes", "pkts" as network.bytes, packets nodrop<br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| network.bytes/1Mi as m\_bytes<br />\| sum(m\_bytes) as total\_mega\_bytes by \_timeslice, server.ip, client.ip<br />\| total\_mega\_bytes as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by server.ip, client.ip<br />\| smooth eventCount as eventCount\_mean by server.ip, client.ip<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by server.ip, client.ip<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|Suspicious Traffic (Megabytes)|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity|\_sourceCategory={{NetworkFirewallLogsdatasource}}  <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "app\_proto", "netflow" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, app\_proto, netflow nodrop<br />\| where event.type="netflow"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br />\| json field=netflow "bytes", "pkts" as network.bytes, packets nodrop<br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| network.bytes/1Mi as m\_bytes<br />\| sum(m\_bytes) as total\_mega\_bytes by \_timeslice, server.ip, client.ip<br />\| total\_mega\_bytes as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by server.ip, client.ip<br />\| smooth eventCount as eventCount\_mean by server.ip, client.ip<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by server.ip, client.ip<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Threats Count AWS API|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  sourceIPAddress !("s3.amazonaws.com")<br />\| json "eventTime", "eventName", "eventSource", "awsRegion", "sourceIPAddress", "errorCode", "userAgent" as event\_time, event.action, eventSource, cloud.region, client.ip, event.outcome, user\_agent nodrop<br />\| json "userIdentity.accountId", "userIdentity.type" as cloud.account.id, user\_identity\_type nodrop<br />\| json field=\_raw "requestParameters.dBInstanceIdentifier", "requestParameters.instancesSet.items[0].instanceId" as db\_instance\_id, cloud\_instance\_id nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name <br /><br />\| parse "\\"userName\\":\\"\*\\"" as user.name nodrop<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(db\_instance\_id),cloud\_instance\_id,db\_instance\_id) as cloud.instance.id<br />\| if(isEmpty(cloud.instance.id),"NA", cloud.instance.id) as cloud.instance.id<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| json field=raw "malware\_families[\*]" as threat\_malware\_families nodrop<br />\| json field=raw "last\_updated" as last\_updated nodrop<br />\| formatDate(fromseconds(last\_updated), "MM-dd-yyyy") as threat\_last\_updated<br />\| json field=raw "labels[\*].name" as label\_name nodrop<br />\| replace(label\_name, "\\\\/","-\>") as label\_name<br />\| replace(label\_name, "\\""," ") as label\_name<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Threats Count AWS Resources|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{GuardDutyLogsdatasource}}  <br />\| json "accountId", "region", "partition", "id", "arn", "type","service.serviceName","service.detectorId","service.action","severity","title","description", "vpcId", "subnetId", "groupId" , "tags", "groupName", "resource.instanceDetails", "resource.accessKeyDetails.userName" as cloud.account.id, cloud.region, partition, id, arn, type, service\_name, detector\_id, action, severity\_level, title, description, vpcId, subnetId , securityGroupId, tags, securityGroupName, instanceDetails, user.name nodrop<br /><br />\| json field=instanceDetails "instanceId", "instanceType","networkInterfaces[0].publicIp" as instanceid, cloud.machine.type, server.ip<br />\| json field=\_raw "resource.resourceType" as resourceType<br />\| json field=\_raw "resource.s3BucketDetails[0].name" as bucketName nodrop<br />\| if (resourceType = "S3Bucket", bucketName, instanceid) as cloud.instance.id<br /><br />\| json field=action "awsApiCallAction.remoteIpDetails.ipAddressV4", "networkConnectionAction.remoteIpDetails.ipAddressV4","networkConnectionAction.localPortDetails.port" as awsCallActionIp, networkActionIp, localPort nodrop<br /><br />\| parse field=type "\*:\*/\*" as threat.tactic.name,cloud.service.name,threat.technique.name <br />\| if (severity\_level = 0, 0, 0) as risk.static\_level<br />\| if (severity\_level \> 0 and severity\_level \<= 2, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 2 and severity\_level \<= 5, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 5 and severity\_level \<= 9, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 9, 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(awsCallActionIp), if (isEmpty(networkActionIp), "NA",networkActionIp) , awsCallActionIp) as client.ip<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />// not filtering on source.user<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Threats Count AWS Storage|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  "s3.amazonaws.com"<br />\| json "userIdentity", "eventTime", "eventSource", "eventName", "awsRegion", "sourceIPAddress", "userAgent", "errorCode", "requestParameters", "eventType" as userIdentity, event\_time, eventSource, event.action, cloud.region, client.ip, user\_agent, event.outcome, requestParameters, eventType nodrop<br />\| where eventSource = "s3.amazonaws.com"<br />\| json field=userIdentity "type", "accountId"as userType, cloud.account.id<br />\| json field=requestParameters "bucketName" as cloud.instance.id<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| if (userType matches("IAMUser"), "user", "machine") as event.agent<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name <br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}"))<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Top 10 Closed Insights by Confidence Level|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight  insightupdated) <br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToResponse", "insight.timeToDetection" ,"insight.timeToRemediation","insight.assignee", "operator.email",  "insight.status", "insight.resolution", "insight.severity", "insight.closed", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.description",  "insight.name", "insight.readableId", "insight.id", "insight.confidence"   as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time, insight\_time\_to\_response , insight\_time\_to\_detection, insight\_time\_to\_remediation , insight\_assignee , operator\_email, insight\_status, insight\_resolution, insight\_severity, insight\_closedAt, insight\_source, entity\_value, entity\_type, entity\_id, insight\_description, insight\_name, insight\_readableId, insight\_Id, insight\_confidence nodrop<br />\| where insight\_status = "closed"<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where  (risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />\| insight\_confidence \* 100 as insight\_confidence <br />\| json field=\_raw "insight.signals.length()" as signal\_count<br />\| replace(insight\_tags, "[","") as insight\_tags<br />\| replace(insight\_tags, "]","") as insight\_tags<br />\| replace(insight\_tags, "\\"","") as insight\_tags<br />\| replace(insight\_tags, ","," \| ") as insight\_tags<br />\| replace(insight\_ruleId, "[","") as insight\_ruleId<br />\| replace(insight\_ruleId, "]","") as insight\_ruleId<br />\| replace(insight\_ruleId, "\\"","") as insight\_ruleId<br />\| replace(insight\_ruleId, ","," \| ") as insight\_ruleId<br /><br />\| if(IsEmpty(insight\_time\_to\_remediation), 0, insight\_time\_to\_remediation) as insight\_time\_to\_remediation<br /><br />\| floor(insight\_time\_to\_remediation/60/60/24) as insight\_time\_to\_remediation\_days<br />\| insight\_time\_to\_remediation - (insight\_time\_to\_remediation\_days\*24\*60\*60) as insight\_time\_to\_remediation<br /><br />\| floor(insight\_time\_to\_remediation/60/60) as insight\_time\_to\_remediation\_hours<br />\| insight\_time\_to\_remediation - (insight\_time\_to\_remediation\_hours\*60\*60) as insight\_time\_to\_remediation<br /><br />\| floor(insight\_time\_to\_remediation/60) as insight\_time\_to\_remediation\_minutes<br />\| insight\_time\_to\_remediation - (insight\_time\_to\_remediation\_minutes\*60) as insight\_time\_to\_remediation<br /><br />\| floor(insight\_time\_to\_remediation) as insight\_time\_to\_remediation\_seconds<br /><br />\| format("%s Days, %s Hrs, %s Min, %s Sec", ToInt(insight\_time\_to\_remediation\_days), ToInt(insight\_time\_to\_remediation\_hours), ToInt(insight\_time\_to\_remediation\_minutes), ToInt(insight\_time\_to\_remediation\_seconds)) as insight\_time\_to\_remediation<br /><br /><br />\| count by insight\_closedAt, insight\_id,signal\_count, insight\_confidence, severity\_name,insight\_description, insight\_name, insight\_assignee ,insight\_ruleId, insight\_tags, insight\_time\_to\_remediation, entity\_value, entity\_type<br />\| sort by insight\_confidence desc<br />\| fields - \_count<br />\| limit 10|
|Cloud Infrastructure Security for AWS|Top 10 Insights Created by Confidence Level|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Cloud SIEM Insights Overview|(\_index=sumologic\_audit\_events \_sourcecategory=cseinsight  insightcreated) OR <br />(\_index=sumologic\_system\_events \_sourcecategory=cseinsight  insightcreated) <br />\| json field=\_raw "insight.signals[\*].ruleId", "insight.tags",  "insight.created", "eventTime", "insight.timeToDetection" ,"insight.assignee", "operator.email",  "insight.status", "insight.severity", "insight.source" , "insight.entityValue","insight.entityType", "insight.entityId", "insight.entitySensorZone" ,"insight.description",  "insight.name", "insight.readableId", "insight.id",  "insight.confidence"  as insight\_ruleId, insight\_tags, insight\_createdAt, insight\_event\_time , insight\_time\_to\_detection , insight\_assignee , operator\_email, insight\_status, insight\_severity, insight\_source, entity\_value, entity\_type, entity\_id, entity\_sensor\_zone ,insight\_description, insight\_name, insight\_readableId, insight\_Id, insight\_confidence nodrop<br />\| json field=\_raw "insight.signals.length()" as signal\_count<br />\| insight\_confidence \* 100 as insight\_confidence <br />\| if(isBlank(insight\_assignee), "Unassigned", insight\_assignee) as insight\_assignee<br />\| replace(insight\_tags, "[","") as insight\_tags<br />\| replace(insight\_tags, "]","") as insight\_tags<br />\| replace(insight\_tags, "\\"","") as insight\_tags<br />\| replace(insight\_tags, ","," \| ") as insight\_tags<br />\| replace(insight\_ruleId, "[","") as insight\_ruleId<br />\| replace(insight\_ruleId, "]","") as insight\_ruleId<br />\| replace(insight\_ruleId, "\\"","") as insight\_ruleId<br />\| replace(insight\_ruleId, ","," \| ") as insight\_ruleId<br />\| json "insight.timeToResponse" as timeToResponse nodrop<br />\| json field=\_raw "insight.severityName" as severity\_name nodrop<br />\| if (severity\_name matches "HIGH", 3, if(severity\_name matches "MEDIUM", 2, if(severity\_name matches "LOW", 1, 0))) as risk.static\_level<br />\| where  (risk.static\_level \>= toInt("{{risk.static\_level}}"))<br /><br />\| if(IsEmpty(insight\_time\_to\_detection), 0, insight\_time\_to\_detection) as insight\_time\_to\_detection<br /><br />\| floor(insight\_time\_to\_detection/60/60/24) as insight\_time\_to\_detection\_days<br />\| insight\_time\_to\_detection - (insight\_time\_to\_detection\_days\*24\*60\*60) as insight\_time\_to\_detection<br /><br />\| floor(insight\_time\_to\_detection/60/60) as insight\_time\_to\_detection\_hours<br />\| insight\_time\_to\_detection - (insight\_time\_to\_detection\_hours\*60\*60) as insight\_time\_to\_detection<br /><br />\| floor(insight\_time\_to\_detection/60) as insight\_time\_to\_detection\_minutes<br />\| insight\_time\_to\_detection - (insight\_time\_to\_detection\_minutes\*60) as insight\_time\_to\_detection<br /><br />\| floor(insight\_time\_to\_detection) as insight\_time\_to\_detection\_seconds<br /><br />\| format("%s Days, %s Hrs, %s Min, %s Sec", ToInt(insight\_time\_to\_detection\_days), ToInt(insight\_time\_to\_detection\_hours), ToInt(insight\_time\_to\_detection\_minutes), ToInt(insight\_time\_to\_detection\_seconds)) as insight\_time\_to\_detection<br /><br />\| count by insight\_createdAt, insight\_readableId,signal\_count ,severity\_name,insight\_confidence, insight\_description, insight\_name, insight\_assignee ,insight\_ruleId , insight\_time\_to\_detection , entity\_value, entity\_type, entity\_id<br />\| fields - \_count<br />\| sort by insight\_confidence desc<br />\| limit 10|
|Cloud Infrastructure Security for AWS|Trend: Blocked Activity Percent|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity|\_sourceCategory={{NetworkFirewallLogsdatasource}}  <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "alert" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, alert nodrop<br />\| where event.type="alert"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="blocked",1,0) as Blocked\_count<br />\| if(event.outcome="allowed",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, server.ip, client.ip<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| avg(eventCount) as avg\_blocked\_pct by \_timeslice|
|Cloud Infrastructure Security for AWS|Trend: Blocked Web Requests Percent|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Web Activity|\_sourceCategory={{WAFLogsdatasource}}  <br />\| json "httpRequest.httpMethod","httpRequest.httpVersion","httpRequest.uri","httpRequest.clientIp","httpRequest.country","action","matchingNonTerminatingRules","rateBasedRuleList","ruleGroupList","httpSourceId","httpSourceName","terminatingRuleType","terminatingRuleId","webaclId" as event.action,http\_version,url.path,client.ip,country,event.outcome,matching\_non\_terminating\_rules,rate\_based\_rule\_list,rule\_group\_list,http\_source\_id,http\_source\_name,terminating\_rule\_type,terminating\_rule\_id,webacl\_id nodrop<br /><br />\| lookup latitude, longitude, country\_code, country\_name, region, city, postal\_code from geo://location on ip = client.ip<br /><br />// global filters<br />\| where if ("{{url.path}}" = "\*", true, url.path matches "{{url.path}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{event.outcome}}" = "\*", true, event.outcome matches "{{event.outcome}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="BLOCK",1,0) as Blocked\_count<br />\| if(event.outcome="ALLOW",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, client.ip,url.path, terminating\_rule\_type,terminating\_rule\_id,event.action,http\_source\_id,http\_source\_name, latitude, longitude, country\_code<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| avg(eventCount) as avg\_blocked\_pct by \_timeslice|
|Cloud Infrastructure Security for AWS|Trend: Suspicious Traffic (Megabytes)|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Network Activity|\_sourceCategory={{NetworkFirewallLogsdatasource}}  <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "app\_proto", "netflow" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, app\_proto, netflow nodrop<br />\| where event.type="netflow"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br />\| json field=netflow "bytes", "pkts" as network.bytes, packets nodrop<br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| network.bytes/1Mi as m\_bytes<br />\| sum(m\_bytes) as total\_mega\_bytes by \_timeslice<br />\| total\_mega\_bytes as eventCount<br />\| sort + \_timeslice<br /><br />\| avg(total\_mega\_bytes) as avg\_outbound\_megabytes by \_timeslice|
|Cloud Infrastructure Security for AWS|Unauthorized API Requests|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("AccessDenied" or "UnauthorizedOperation")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where !isBlank(event.action) or !isBlank(user.name)<br />\| where error\_code="AccessDenied" or error\_code="UnauthorizedOperation"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Unauthorized API Requests|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  ("AccessDenied" or "UnauthorizedOperation")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br /><br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where !isBlank(event.action) or !isBlank(user.name)<br />\| where error\_code="AccessDenied" or error\_code="UnauthorizedOperation"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|Unauthorized AWS API Requests|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious User Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("AccessDenied" or "UnauthorizedOperation")<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where !isBlank(event.action) or !isBlank(user.name)<br />\| where error\_code="AccessDenied" or error\_code="UnauthorizedOperation"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS|VPC Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Risk Overview|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateVpc" or "DeleteVpc" or "ModifyVpcAttribute" or \*VpcPeeringConnection or \*tachClassicLink or \*ableVpcClassic)<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name <br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateVpc" or event.action matches "DeleteVpc" or event.action matches "ModifyVpcAttribute" or event.action matches "\*VpcPeeringConnection" or event.action matches "\*tachClassicLink" or event.action matches "\*ableVpcClassic"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS|VPC Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateVpc" or "DeleteVpc" or "ModifyVpcAttribute" or \*VpcPeeringConnection or \*tachClassicLink or \*ableVpcClassic)<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateVpc" or event.action matches "DeleteVpc" or event.action matches "ModifyVpcAttribute" or event.action matches "\*VpcPeeringConnection" or event.action matches "\*tachClassicLink" or event.action matches "\*ableVpcClassic"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS/Saved Searches|VPC Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Saved Searches/VPC Changes|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateVpc" or "DeleteVpc" or "ModifyVpcAttribute" or \*VpcPeeringConnection or \*tachClassicLink or \*ableVpcClassic)<br />\| json "requestID","eventID","userIdentity.accountId","sourceIPAddress","awsRegion","eventName","eventType" as request\_id, event\_id,acc\_id,source\_ip,region,event\_name,event\_type nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user\_name <br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where eventName matches "CreateVpc" or eventName matches "DeleteVpc" or eventName matches "ModifyVpcAttribute" or eventName matches "\*VpcPeeringConnection" or eventName matches "\*tachClassicLink" or eventName matches "\*ableVpcClassic"<br />\| count as frequency by user\_name,acc\_id<br />\| sort by frequency<br />\| limit 100|
|Cloud Infrastructure Security for AWS|VPC Changes|Logs|Installed Apps/Cloud Infrastructure Security for AWS/Suspicious Config and IAM Activity|\_sourceCategory={{CloudTrailLogsdatasource}}  ("CreateVpc" or "DeleteVpc" or "ModifyVpcAttribute" or \*VpcPeeringConnection or \*tachClassicLink or \*ableVpcClassic)<br />\| json "eventName","sourceIPAddress","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| parse regex "\\"(?i)userName\\":\\"(?\<user\_name\>.\*?)\\"" nodrop<br />\| parse "\\"userId\\":\\"\*\\"" as user\_id nodrop<br />\| if (user\_name="", user\_id, user\_name) as user.name<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateVpc" or event.action matches "DeleteVpc" or event.action matches "ModifyVpcAttribute" or event.action matches "\*VpcPeeringConnection" or event.action matches "\*tachClassicLink" or event.action matches "\*ableVpcClassic"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|

