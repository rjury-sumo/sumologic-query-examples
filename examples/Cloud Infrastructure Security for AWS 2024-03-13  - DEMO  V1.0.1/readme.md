# Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1

## Searches

### Log Searches

- **Action Plan**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Resources 
- **Action Plan: Security Control Failures**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Admin Privileges Granted**: from Search: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Admin Privileges Granted 
- **All AWS API Events By Time**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Config Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **Config Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **Config Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Console Logins from Risky Geo Locations**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity 
- **Console Logins Without MFA**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity 
- **Console Logins Without MFA**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity 
- **Console Logins Without MFA**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Control Failure Findings Details by Severity**: from Search: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Control Failure Findings Details by Severity 
- **Creation of IAM Role**: from Search: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Creation of IAM Role 
- **Deleted resources over time**: from Search: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Deleted resources over time 
- **Disabled or Scheduled Deletion of CMK**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **Disabled or Scheduled Deletion of CMKs**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Disabled or Scheduled Deletion of CMKs**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **Exposed S3 Bucket Created**: from Search: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Exposed S3 Bucket Created 
- **Failed Console Logins**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Failed Console Logins**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity 
- **Failed Console Logins**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity 
- **Finding Count**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Security Control Failures 
- **Findings by Category**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Resources 
- **Findings by Category**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Security Control Failures 
- **Findings by Resource**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Security Control Failures 
- **Findings by Resource**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Resources 
- **Findings by Resource Type**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Security Control Failures 
- **Findings by Resource Type**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Resources 
- **Findings Trend**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Resources 
- **Findings Trend**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Security Control Failures 
- **Gateway Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Gateway Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **Gateway Changes**: from Search: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Gateway Changes 
- **Gateway Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **IAM Policy Changes**: from Search: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/IAM Policy Changes 
- **IAM Policy Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **IAM Policy Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **IAM Policy Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **Impossible Travel Events**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity 
- **Impossible Travel Events**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Impossible Travel Events**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity 
- **Least Common Out of Compliance Findings**: from Search: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Least Common Out of Compliance Findings 
- **Most Common Out of Compliance Findings**: from Search: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Most Common Out of Compliance Findings 
- **Network ACL Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **Network ACL Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **Network ACL Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Network ACL Changes**: from Search: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Network ACL Changes 
- **New Admins Added**: from Search: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/New Admins Added 
- **Permissive S3 Buckets Created**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Permissive S3 Buckets Created**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **Permissive S3 Buckets Created**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **Root Account Logins**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity 
- **Root Account Logins**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Root Account Logins**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity 
- **Route Table Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **Route Table Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **Route Table Changes**: from Search: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Route Table Changes 
- **Route Table Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **S3 Bucket Changes**: from Search: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/S3 Bucket Changes 
- **S3 Bucket Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **S3 Bucket Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **S3 Bucket Permission Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **Security Control Failures**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Security Group Changes**: from Search: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Security Group Changes 
- **Security Group Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **Security Group Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **Security Group Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Suspicious Blocked Destinations by Location**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity 
- **Suspicious Blocked Source-Destination Pairs**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity 
- **Suspicious Blocked Source-Destination Pairs**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity 
- **Suspicious Blocked Source-Destination Pairs**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Suspicious Blocked Web Requests**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Web Activity 
- **Suspicious Blocked Web Requests**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Web Activity 
- **Suspicious Blocked Web Requests**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Suspicious Blocked Web Requests by Location**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Web Activity 
- **Suspicious Destinations by Traffic (Megabytes)**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity 
- **Suspicious Megabytes Source-Destination Pairs**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity 
- **Suspicious Traffic (Megabytes)**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity 
- **Threats by Actor**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Storage 
- **Threats by Actor**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS APIs 
- **Threats by Country**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Resources 
- **Threats by Events and Result**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS APIs 
- **Threats by Events and Result**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Storage 
- **Threats by Geo Location**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS APIs 
- **Threats by Geo Location**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Storage 
- **Threats by Resource**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Storage 
- **Threats by Resource**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS APIs 
- **Threats Count**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Storage 
- **Threats Count**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS APIs 
- **Threats Count AWS API**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Threats Count AWS Resources**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Threats Count AWS Storage**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Threats Trend**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Storage 
- **Threats Trend**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS APIs 
- **Total Findings**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Resources 
- **Trend: Blocked Activity Percent**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity 
- **Trend: Blocked Web Requests Percent**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Web Activity 
- **Trend: Suspicious Traffic (Megabytes)**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity 
- **Unauthorized API Requests**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity 
- **Unauthorized API Requests**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview 
- **Unauthorized AWS API Requests**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity 
- **VPC Changes**: from Search: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/VPC Changes 
- **VPC Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **VPC Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity 
- **VPC Changes**: from Dashboard: Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview

### Metric Searches


## Search Table

|app\_topic|search\_name|type|origin|search|
|:--|:--|:--|:--|:--|
||Action Plan|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Resources|\_sourceCategory=PDET/CIS/AWS/GuardDuty <br />\| json "accountId", "region", "partition", "id", "arn", "type","service.serviceName","service.detectorId","service.action","severity","title","description", "vpcId", "subnetId", "groupId" , "tags", "groupName", "resource.instanceDetails", "resource.accessKeyDetails.userName" as cloud.account.id, cloud.region, partition, id, arn, type, service\_name, detector\_id, action, severity\_level, title, description, vpcId, subnetId , securityGroupId, tags, securityGroupName, instanceDetails, user.name nodrop<br /><br />\| json field=instanceDetails "instanceId", "instanceType","networkInterfaces[0].publicIp" as instanceid, cloud.machine.type, server.ip<br />\| json field=\_raw "resource.resourceType" as resourceType<br />\| json field=\_raw "resource.s3BucketDetails[0].name" as bucketName nodrop<br />\| if (resourceType = "S3Bucket", bucketName, instanceid) as cloud.instance.id<br /><br />\| json field=action "awsApiCallAction.remoteIpDetails.ipAddressV4", "networkConnectionAction.remoteIpDetails.ipAddressV4","networkConnectionAction.localPortDetails.port","networkConnectionAction.remoteIpDetails.geoLocation.lon", "networkConnectionAction.remoteIpDetails.geoLocation.lat", "networkConnectionAction.remoteIpDetails.organization.asnOrg", "networkConnectionAction.remoteIpDetails.organization.org", "networkConnectionAction.remoteIpDetails.organization.isp" as awsCallActionIp, networkActionIp, localPort,longitude, latitude, asnOrg, organization, isp nodrop<br /><br />\| parse field=type "\*:\*/\*" as threat.tactic.name,cloud.service.name,threat.technique.name <br />\| if (severity\_level = 0, 0, 0) as risk.static\_level<br />\| if (severity\_level \> 0 and severity\_level \<= 2, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 2 and severity\_level \<= 5, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 5 and severity\_level \<= 9, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 9, 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(awsCallActionIp), if (isEmpty(networkActionIp), "NA",networkActionIp) , awsCallActionIp) as client.ip<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{threat.tactic.name}}" = "\*", true, threat.tactic.name matches "{{threat.tactic.name}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}")<br /><br />\| if(!isNull(cloud.instance.id),concat ("https://",region,".console.aws.amazon.com/ec2/v2/home?region=",cloud.region,"#Instances:search=",cloud.instance.id),"") as link<br />\| tourl (link, cloud.account.id) as cloud.account.id<br />\| count as frequency by title, cloud.account.id, cloud.service.name, organization, isp, client.ip<br />\| sort by frequency|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Action Plan: Security Control Failures|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=Labs/AWS/SecurityHub ({{cloud.instance.id}} AND {{client.ip}} AND {{user.name}} AND {{cloud.account.id}} AND {{cloud.region}})<br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName", "Resources[0].Details.AwsIamAccessKey.UserName" as cloud.account.id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName, user.name nodrop<br /><br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br />\| parse field=finding\_type "\*/\*/\*" as rule.ruleset, rule.category, rule.name<br /><br />\| if (severity\_normalized == 0, 0, 0) as risk.static\_level<br />\| if (severity\_normalized \> 0.and severity\_normalized \<= 40, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 40 and severity\_normalized \<= 70, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 70 and severity\_normalized \<= 90, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \>= 90, 3, risk.static\_level) as risk.static\_level<br /><br />// global filters<br />\| where if("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if("{{user.name}}" = "\*", true, user.name matches "{{user.name}}")<br />\| where if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) <br /><br />\| format("https://console.aws.amazon.com/securityhub/home?region=%s#/research?Id=%s", sechub\_region, finding\_id) as finding\_url<br />\| tourl(finding\_url, title) as title<br />\| count by title, source,risk.static\_level, updated\_at, resource\_type, finding\_type, resource\_id, cloud.account.id, finding\_provider<br />\| sort by risk.static\_level desc<br />\| fields -\_count<br />\| limit 100|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches|Admin Privileges Granted|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Admin Privileges Granted|\_sourceCategory=\*CloudTrail\*<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage","requestParameters.policyArn" as event\_name,source\_ip,user\_name,user\_principal, login\_result,mfa\_used,event\_source,aws\_region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,acc\_id,error\_message,policy\_arn nodrop<br />\| if(user\_name = "",user\_principal,user\_name) as user\_name<br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where aws\_region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where event\_name matches("\*AttachUserPolicy\*")<br />\| where policy\_arn matches("\*AdministratorAccess\*")<br /><br />\| count by acc\_id,event\_type,user\_name,event\_time,event\_source,aws\_region<br />\| sort by event\_time<br />\| limit 100|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|All AWS API Events By Time|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* <br />\| json "requestID","eventID","userIdentity.sessionContext.sessionIssuer.userName","userIdentity.accountId","userIdentity.type","sourceIPAddress","awsRegion","eventName" as request\_id, event\_id,user.name,cloud.account.id,user\_identity\_type,client.ip,cloud.region,event.action<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br /><br />\| json field=\_raw "requestParameters.dBInstanceIdentifier" as db\_instance\_id nodrop<br />\| json field=\_raw "requestParameters.instancesSet.items[0].instanceId" as cloud\_instance\_id nodrop<br />\| if(isEmpty(db\_instance\_id),cloud\_instance\_id,db\_instance\_id) as cloud.instance.id<br />\| if(isEmpty(cloud.instance.id),"NA", cloud.instance.id) as cloud.instance.id<br /><br />\| parse field=eventSource "\*." as cloud.service.name<br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br /><br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by event.action, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by event.action<br />\| smooth eventCount as eventCount\_mean by event.action<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| fields \_timeslice, event.action, zscore<br />\| sort + \_timeslice<br />\| transpose row \_timeslice column event.action|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Config Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("StopConfigurationRecorder" or "DeleteDeliveryChannel" or "PutDeliveryChannel" or "PutConfigurationRecorder")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "StopConfigurationRecorder" or event.action matches "DeleteDeliveryChannel" or event.action matches "PutDeliveryChannel" or event.action matches "PutConfigurationRecorder"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Config Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("StopConfigurationRecorder" or "DeleteDeliveryChannel" or "PutDeliveryChannel" or "PutConfigurationRecorder")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "StopConfigurationRecorder" or event.action matches "DeleteDeliveryChannel" or event.action matches "PutDeliveryChannel" or event.action matches "PutConfigurationRecorder"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Config Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* ("StopConfigurationRecorder" or "DeleteDeliveryChannel" or "PutDeliveryChannel" or "PutConfigurationRecorder")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "StopConfigurationRecorder" or event.action matches "DeleteDeliveryChannel" or event.action matches "PutDeliveryChannel" or event.action matches "PutConfigurationRecorder"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Console Logins from Risky Geo Locations|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity|\_sourceCategory=\*CloudTrail\* ConsoleLogin<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("\*ConsoleLogin\*")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| where isValidIPv4(client.ip) or isValidIPv6(client.ip)<br />\| where !isNull(client.ip)<br />\| if(isValidIPv4(client.ip), if(!isPrivateIP(client.ip),true,false),true) as is\_public<br />\| where is\_public<br />\| count as frequency by client.ip<br />\| lookup latitude, longitude, country\_code from geo://location on ip = client.ip<br />\| lookup country\_code from https://sumologic-app-data.s3.amazonaws.com/riskycountries.csv on country\_code=country\_code<br />\| where !isEmpty(country\_code)|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Console Logins Without MFA|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity|\_sourceCategory=\*CloudTrail\* ConsoleLogin<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("\*ConsoleLogin\*")<br />\| where mfa\_used\<\>"Yes"<br />\| where login\_result = "Success"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Console Logins Without MFA|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity|\_sourceCategory=\*CloudTrail\* ConsoleLogin<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("\*ConsoleLogin\*")<br />\| where mfa\_used\<\>"Yes"<br />\| where login\_result = "Success"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Console Logins Without MFA|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* ConsoleLogin<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}")AND if ("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("\*ConsoleLogin\*")<br />\| where mfa\_used\<\>"Yes"<br />\| where login\_result = "Success"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches|Control Failure Findings Details by Severity|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Control Failure Findings Details by Severity|\_sourceCategory=Labs/AWS/SecurityHub <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName" as account\_id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName nodrop<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, "Informational", "Others") as severity<br />\| if (severity\_normalized \<= 39, "Low", severity) as severity<br />\| if ((severity\_normalized \<= 69) and (severity\_normalized \>= 40), "Medium", severity) as severity<br />\| if ((severity\_normalized \<= 89) and (severity\_normalized \>= 70), "High", severity) as severity<br />\| if (severity\_normalized \<= 100 and severity\_normalized \>= 90, "Critical", severity) as severity<br /><br />// global filters<br />\| where account\_id matches "\*"<br />\| where finding\_id matches "\*"<br />\| where finding\_type matches "\*"<br />\| where finding\_provider matches "\*"<br />\| where severity matches "\*"<br />\| where compliance\_status matches "\*"<br /><br />\| format("https://console.aws.amazon.com/securityhub/home?region=%s#/research?Id=%s", sechub\_region, finding\_id) as finding\_url<br />\| tourl(finding\_url, title) as title<br /><br />\| top 100 title,source,severity,compliance\_status, updated\_at, resource\_type, finding\_type, resource\_id, account\_id, finding\_provider by updated\_at|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches|Creation of IAM Role|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Creation of IAM Role|\_sourceCategory=\*CloudTrail\* CreateRole<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event\_name,source\_ip,user\_name,user\_principal, login\_result,mfa\_used,event\_source,aws\_region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,acc\_id,error\_message nodrop<br />\| if(user\_name = "",user\_principal,user\_name) as user\_name<br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where aws\_region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where event\_name matches("\*CreateRole\*")<br />\| formatDate(toLong(\_messageTime), "MM-dd-yyyy HH:mm:ss") as event\_time<br />\| count by user\_name,event\_source,aws\_region,event\_type,event\_category,user\_identity\_type,event\_time<br />\| top 100 user\_name,event\_source,aws\_region,event\_type,event\_category,user\_identity\_type by event\_time|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches|Deleted resources over time|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Deleted resources over time|\_sourceCategory=\*CloudTrail\* Delete\*<br /> \| parse "\\"userName\\":\\"\*\\"" as user\_name nodrop<br /> \| json field=\_raw "userIdentity.principalId" as principal\_id nodrop<br /> \| parse regex field = principal\_id ":(?\<user\_principal\>.+)" nodrop<br /> \| if (user\_name="", user\_principal, user\_name) as user \| parse "\\"eventName\\":\\"\*\\"" as event\_name<br /> \| timeslice 1h <br /> \| parse regex field=event\_name "^(?:Delete)(?\<resource\_type\>[A-Z][A-Za-z]+)"<br /> \| count \_timeslice, resource\_type<br /> \| transpose row \_timeslice column resource\_type|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Disabled or Scheduled Deletion of CMK|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("DisableKey" or "ScheduleKeyDeletion")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "DisableKey" or event.action matches "ScheduleKeyDeletion"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Disabled or Scheduled Deletion of CMKs|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* ("DisableKey" or "ScheduleKeyDeletion")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "DisableKey" or event.action matches "ScheduleKeyDeletion"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Disabled or Scheduled Deletion of CMKs|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("DisableKey" or "ScheduleKeyDeletion")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "DisableKey" or event.action matches "ScheduleKeyDeletion"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches|Exposed S3 Bucket Created|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Exposed S3 Bucket Created|\_sourceCategory=\*CloudTrail\* ("PutBucketAcl" or "\*FULL\_CONTROL\*")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event\_name,source\_ip,user\_name,user\_principal, login\_result,mfa\_used,event\_source,aws\_region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,acc\_id,error\_message nodrop<br />\| if(user\_name = "",user\_principal,user\_name) as user\_name<br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where aws\_region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where event\_name matches("PutBucketAcl")<br />\| where permission matches("\*FULL\_CONTROL\*")<br />\| count by user\_name,user\_identity\_type,event\_source,event\_type,event\_time,aws\_region<br />\| top 100 user\_name,user\_identity\_type,event\_source,event\_type,event\_time,aws\_region by event\_time|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Failed Console Logins|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* ("ConsoleLogin" and "Failed authentication")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where (event.action matches "ConsoleLogin" and error\_message matches "Failed authentication")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Failed Console Logins|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity|\_sourceCategory=\*CloudTrail\* ("ConsoleLogin" and "Failed authentication")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where (event.action matches "ConsoleLogin" and error\_message matches "Failed authentication")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Failed Console Logins|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity|\_sourceCategory=\*CloudTrail\* ("ConsoleLogin" and "Failed authentication")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where (event.action matches "ConsoleLogin" and error\_message matches "Failed authentication")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Finding Count|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Security Control Failures|\_sourceCategory=Labs/AWS/SecurityHub <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName", "Resources[0].Details.AwsIamAccessKey.UserName" as cloud.account.id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName, user.name nodrop<br /><br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, 0, 0) as risk.static\_level<br />\| if (severity\_normalized \> 0 and severity\_normalized \<= 40, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 40 and severity\_normalized \<= 70, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 70 and severity\_normalized \<= 90, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 90 and severity\_normalized \<= 100, 3, risk.static\_level) as risk.static\_level<br /><br />\| parse field=finding\_type "\*/\*/\*" as rule.ruleset, rule.category, rule.name<br /><br />\| resource\_type as cloud.service.name<br />\| resource\_id as cloud.instance.id<br />\| sechub\_region as cloud.region<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{rule.ruleset}}" = "\*", true, rule.ruleset matches "{{rule.ruleset}}") AND if ("{{rule.author}}" = "\*", true, finding\_provider matches "{{rule.author}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{compliance\_status}}" = "\*", true, compliance\_status matches "{{compliance\_status}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{rule.category}}" = "\*", true, rule.category matches "{{rule.category}}")<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| count (finding\_id)|
||Findings by Category|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Resources|\_sourceCategory=PDET/CIS/AWS/GuardDuty <br />\| json "accountId", "region", "partition", "id", "arn", "type","service.serviceName","service.detectorId","service.action","severity","title","description", "vpcId", "subnetId", "groupId" , "tags", "groupName", "resource.instanceDetails", "resource.accessKeyDetails.userName" as cloud.account.id, cloud.region, partition, id, arn, type, service\_name, detector\_id, action, severity\_level, title, description, vpcId, subnetId , securityGroupId, tags, securityGroupName, instanceDetails, user.name nodrop<br /><br />\| json field=instanceDetails "instanceId", "instanceType","networkInterfaces[0].publicIp" as instanceid, cloud.machine.type, server.ip<br />\| json field=\_raw "resource.resourceType" as resourceType<br />\| json field=\_raw "resource.s3BucketDetails[0].name" as bucketName nodrop<br />\| if (resourceType = "S3Bucket", bucketName, instanceid) as cloud.instance.id<br /><br />\| json field=action "awsApiCallAction.remoteIpDetails.ipAddressV4", "networkConnectionAction.remoteIpDetails.ipAddressV4","networkConnectionAction.localPortDetails.port" as awsCallActionIp, networkActionIp, localPort nodrop<br /><br />\| parse field=type "\*:\*/\*" as threat.tactic.name,cloud.service.name,threat.technique.name <br />\| if (severity\_level = 0, 0, 0) as risk.static\_level<br />\| if (severity\_level \> 0 and severity\_level \<= 2, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 2 and severity\_level \<= 5, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 5 and severity\_level \<= 9, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 9, 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(awsCallActionIp), if (isEmpty(networkActionIp), "NA",networkActionIp) , awsCallActionIp) as client.ip<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{threat.tactic.name}}" = "\*", true, threat.tactic.name matches "{{threat.tactic.name}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}")<br /><br />\| count by threat.tactic.name<br />\| sort by \_count<br />\| limit 10|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Findings by Category|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Security Control Failures|\_sourceCategory=Labs/AWS/SecurityHub <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName", "Resources[0].Details.AwsIamAccessKey.UserName" as cloud.account.id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName, user.name nodrop<br /><br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, 0, 0) as risk.static\_level<br />\| if (severity\_normalized \> 0 and severity\_normalized \<= 40, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 40 and severity\_normalized \<= 70, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 70 and severity\_normalized \<= 90, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 90 and severity\_normalized \<= 100, 3, risk.static\_level) as risk.static\_level<br /><br />\| parse field=finding\_type "\*/\*/\*" as rule.ruleset, rule.category, rule.name<br /><br />\| resource\_type as cloud.service.name<br />\| resource\_id as cloud.instance.id<br />\| sechub\_region as cloud.region<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{rule.ruleset}}" = "\*", true, rule.ruleset matches "{{rule.ruleset}}") AND if ("{{rule.author}}" = "\*", true, finding\_provider matches "{{rule.author}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{compliance\_status}}" = "\*", true, compliance\_status matches "{{compliance\_status}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{rule.category}}" = "\*", true, rule.category matches "{{rule.category}}")<br /><br />\| count(finding\_id) by rule.category<br />\| sort by \_count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Findings by Resource|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Security Control Failures|\_sourceCategory=Labs/AWS/SecurityHub <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName", "Resources[0].Details.AwsIamAccessKey.UserName" as cloud.account.id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName, user.name nodrop<br /><br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, 0, 0) as risk.static\_level<br />\| if (severity\_normalized \> 0 and severity\_normalized \<= 40, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 40 and severity\_normalized \<= 70, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 70 and severity\_normalized \<= 90, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 90 and severity\_normalized \<= 100, 3, risk.static\_level) as risk.static\_level<br /><br />\| parse field=finding\_type "\*/\*/\*" as rule.ruleset, rule.category, rule.name<br /><br />\| resource\_type as cloud.service.name<br />\| resource\_id as cloud.instance.id<br />\| sechub\_region as cloud.region<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{rule.ruleset}}" = "\*", true, rule.ruleset matches "{{rule.ruleset}}") AND if ("{{rule.author}}" = "\*", true, finding\_provider matches "{{rule.author}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{compliance\_status}}" = "\*", true, compliance\_status matches "{{compliance\_status}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{rule.category}}" = "\*", true, rule.category matches "{{rule.category}}")<br /><br />\| count by cloud.instance.id, user.name, cloud.region, cloud.account.id<br />\| sort by \_count|
||Findings by Resource|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Resources|\_sourceCategory=PDET/CIS/AWS/GuardDuty <br />\| json "accountId", "region", "partition", "id", "arn", "type","service.serviceName","service.detectorId","service.action","severity","title","description", "vpcId", "subnetId", "groupId" , "tags", "groupName", "resource.instanceDetails", "resource.accessKeyDetails.userName" as cloud.account.id, cloud.region, partition, id, arn, type, service\_name, detector\_id, action, severity\_level, title, description, vpcId, subnetId , securityGroupId, tags, securityGroupName, instanceDetails, user.name nodrop<br /><br />\| json field=instanceDetails "instanceId", "instanceType","networkInterfaces[0].publicIp" as instanceid, cloud.machine.type, server.ip<br />\| json field=\_raw "resource.resourceType" as resourceType<br />\| json field=\_raw "resource.s3BucketDetails[0].name" as bucketName nodrop<br />\| if (resourceType = "S3Bucket", bucketName, instanceid) as cloud.instance.id<br /><br />\| json field=action "awsApiCallAction.remoteIpDetails.ipAddressV4", "networkConnectionAction.remoteIpDetails.ipAddressV4","networkConnectionAction.localPortDetails.port" as awsCallActionIp, networkActionIp, localPort nodrop<br /><br />\| parse field=type "\*:\*/\*" as threat.tactic.name,cloud.service.name,threat.technique.name <br />\| if (severity\_level = 0, 0, 0) as risk.static\_level<br />\| if (severity\_level \> 0 and severity\_level \<= 2, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 2 and severity\_level \<= 5, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 5 and severity\_level \<= 9, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 9, 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(awsCallActionIp), if (isEmpty(networkActionIp), "NA",networkActionIp) , awsCallActionIp) as client.ip<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{threat.tactic.name}}" = "\*", true, threat.tactic.name matches "{{threat.tactic.name}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}")<br /><br />\| count by cloud.instance.id, cloud.account.id, cloud.region, risk.static\_level,threat.tactic.name,cloud.service.name,threat.technique.name, user.name, client.ip<br />\| sort by \_count<br />\| limit 10|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Findings by Resource Type|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Security Control Failures|\_sourceCategory=Labs/AWS/SecurityHub <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName", "Resources[0].Details.AwsIamAccessKey.UserName" as cloud.account.id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName, user.name nodrop<br /><br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, 0, 0) as risk.static\_level<br />\| if (severity\_normalized \> 0 and severity\_normalized \<= 40, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 40 and severity\_normalized \<= 70, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 70 and severity\_normalized \<= 90, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 90 and severity\_normalized \<= 100, 3, risk.static\_level) as risk.static\_level<br /><br />\| parse field=finding\_type "\*/\*/\*" as rule.ruleset, rule.category, rule.name<br /><br />\| resource\_type as cloud.service.name<br />\| resource\_id as cloud.instance.id<br />\| sechub\_region as cloud.region<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{rule.ruleset}}" = "\*", true, rule.ruleset matches "{{rule.ruleset}}") AND if ("{{rule.author}}" = "\*", true, finding\_provider matches "{{rule.author}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{compliance\_status}}" = "\*", true, compliance\_status matches "{{compliance\_status}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{rule.category}}" = "\*", true, rule.category matches "{{rule.category}}")<br /><br />\| count by cloud.service.name<br />\| sort by \_count|
||Findings by Resource Type|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Resources|\_sourceCategory=PDET/CIS/AWS/GuardDuty <br />\| json "accountId", "region", "partition", "id", "arn", "type","service.serviceName","service.detectorId","service.action","severity","title","description", "vpcId", "subnetId", "groupId" , "tags", "groupName", "resource.instanceDetails", "resource.accessKeyDetails.userName" as cloud.account.id, cloud.region, partition, id, arn, type, service\_name, detector\_id, action, severity\_level, title, description, vpcId, subnetId , securityGroupId, tags, securityGroupName, instanceDetails, user.name nodrop<br /><br />\| json field=instanceDetails "instanceId", "instanceType","networkInterfaces[0].publicIp" as instanceid, cloud.machine.type, server.ip<br />\| json field=\_raw "resource.resourceType" as resourceType<br />\| json field=\_raw "resource.s3BucketDetails[0].name" as bucketName nodrop<br />\| if (resourceType = "S3Bucket", bucketName, instanceid) as cloud.instance.id<br /><br />\| json field=action "awsApiCallAction.remoteIpDetails.ipAddressV4", "networkConnectionAction.remoteIpDetails.ipAddressV4","networkConnectionAction.localPortDetails.port" as awsCallActionIp, networkActionIp, localPort nodrop<br /><br />\| parse field=type "\*:\*/\*" as threat.tactic.name,cloud.service.name,threat.technique.name <br />\| if (severity\_level = 0, 0, 0) as risk.static\_level<br />\| if (severity\_level \> 0 and severity\_level \<= 2, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 2 and severity\_level \<= 5, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 5 and severity\_level \<= 9, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 9, 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(awsCallActionIp), if (isEmpty(networkActionIp), "NA",networkActionIp) , awsCallActionIp) as client.ip<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{threat.tactic.name}}" = "\*", true, threat.tactic.name matches "{{threat.tactic.name}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}")<br /><br />\| count by cloud.service.name<br />\| sort by \_count<br />\| limit 10|
||Findings Trend|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Resources|\_sourceCategory=PDET/CIS/AWS/GuardDuty <br />\| json "accountId", "region", "partition", "id", "arn", "type","service.serviceName","service.detectorId","service.action","severity","title","description", "vpcId", "subnetId", "groupId" , "tags", "groupName", "resource.instanceDetails", "resource.accessKeyDetails.userName" as cloud.account.id, cloud.region, partition, id, arn, type, service\_name, detector\_id, action, severity\_level, title, description, vpcId, subnetId , securityGroupId, tags, securityGroupName, instanceDetails, user.name nodrop<br /><br />\| json field=instanceDetails "instanceId", "instanceType","networkInterfaces[0].publicIp" as instanceid, cloud.machine.type, server.ip<br />\| json field=\_raw "resource.resourceType" as resourceType<br />\| json field=\_raw "resource.s3BucketDetails[0].name" as bucketName nodrop<br />\| if (resourceType = "S3Bucket", bucketName, instanceid) as cloud.instance.id<br /><br />\| json field=action "awsApiCallAction.remoteIpDetails.ipAddressV4", "networkConnectionAction.remoteIpDetails.ipAddressV4","networkConnectionAction.localPortDetails.port" as awsCallActionIp, networkActionIp, localPort nodrop<br /><br />\| parse field=type "\*:\*/\*" as threat.tactic.name,cloud.service.name,threat.technique.name <br />\| if (severity\_level = 0, 0, 0) as risk.static\_level<br />\| if (severity\_level \> 0 and severity\_level \<= 2, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 2 and severity\_level \<= 5, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 5 and severity\_level \<= 9, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 9, 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(awsCallActionIp), if (isEmpty(networkActionIp), "NA",networkActionIp) , awsCallActionIp) as client.ip<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{threat.tactic.name}}" = "\*", true, threat.tactic.name matches "{{threat.tactic.name}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}")<br /><br />\| timeslice 1d<br />\| count by \_timeslice|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Findings Trend|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Security Control Failures|\_sourceCategory=Labs/AWS/SecurityHub <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName", "Resources[0].Details.AwsIamAccessKey.UserName" as cloud.account.id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName, user.name nodrop<br /><br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, 0, 0) as risk.static\_level<br />\| if (severity\_normalized \> 0 and severity\_normalized \<= 40, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 40 and severity\_normalized \<= 70, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 70 and severity\_normalized \<= 90, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 90 and severity\_normalized \<= 100, 3, risk.static\_level) as risk.static\_level<br /><br />\| parse field=finding\_type "\*/\*/\*" as rule.ruleset, rule.category, rule.name<br /><br />\| resource\_type as cloud.service.name<br />\| resource\_id as cloud.instance.id<br />\| sechub\_region as cloud.region<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{rule.ruleset}}" = "\*", true, rule.ruleset matches "{{rule.ruleset}}") AND if ("{{rule.author}}" = "\*", true, finding\_provider matches "{{rule.author}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{compliance\_status}}" = "\*", true, compliance\_status matches "{{compliance\_status}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{rule.category}}" = "\*", true, rule.category matches "{{rule.category}}")<br /> <br />\| timeslice 1d<br />\| count(finding\_id) by \_timeslice|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Gateway Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* ("CreateCustomerGateway" or "DeleteCustomerGateway" or "AttachInternetGateway" or "CreateInternetGateway" or "DeleteInternetGateway" or "DetachInternetGateway")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateCustomerGateway" or event.action matches "DeleteCustomerGateway" or event.action matches "AttachInternetGateway" or event.action matches "CreateInternetGateway" or event.action matches "DeleteInternetGateway" or event.action matches "DetachInternetGateway"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Gateway Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("CreateCustomerGateway" or "DeleteCustomerGateway" or "AttachInternetGateway" or "CreateInternetGateway" or "DeleteInternetGateway" or "DetachInternetGateway")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateCustomerGateway" or event.action matches "DeleteCustomerGateway" or event.action matches "AttachInternetGateway" or event.action matches "CreateInternetGateway" or event.action matches "DeleteInternetGateway" or event.action matches "DetachInternetGateway"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches|Gateway Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Gateway Changes|\_sourceCategory=\*CloudTrail\* ("CreateCustomerGateway" or "DeleteCustomerGateway" or "AttachInternetGateway" or "CreateInternetGateway" or "DeleteInternetGateway" or "DetachInternetGateway")<br />\| json "requestID","eventID","userIdentity.sessionContext.sessionIssuer.userName","userIdentity.accountId","sourceIPAddress","awsRegion","eventName","eventType" as request\_id, event\_id,user\_name,acc\_id,source\_ip,region,event\_name,event\_type nodrop<br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where eventName matches "CreateCustomerGateway" or eventName matches "DeleteCustomerGateway" or eventName matches "AttachInternetGateway" or eventName matches "CreateInternetGateway" or eventName matches "DeleteInternetGateway" or eventName matches "DetachInternetGateway"<br />\| count as frequency by user\_name,acc\_id<br />\| sort by frequency<br />\| limit 100|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Gateway Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("CreateCustomerGateway" or "DeleteCustomerGateway" or "AttachInternetGateway" or "CreateInternetGateway" or "DeleteInternetGateway" or "DetachInternetGateway")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateCustomerGateway" or event.action matches "DeleteCustomerGateway" or event.action matches "AttachInternetGateway" or event.action matches "CreateInternetGateway" or event.action matches "DeleteInternetGateway" or event.action matches "DetachInternetGateway"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches|IAM Policy Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/IAM Policy Changes|\_sourceCategory=\*CloudTrail\*<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event\_name,source\_ip,user\_name,user\_principal, login\_result,mfa\_used,event\_source,aws\_region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,acc\_id,error\_message nodrop<br />\| if(user\_name = "",user\_principal,user\_name) as user\_name<br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where aws\_region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where event\_name matches("Add\*") or event\_name matches("Attach\*") or event\_name matches("Change\*") or event\_name matches("Create\*") or event\_name matches("Deactivate\*") or event\_name matches("Delete\*") or event\_name matches("Detach\*") or event\_name matches("Enable\*") or event\_name matches("Put\*") or event\_name matches("Remove\*") or event\_name matches("Set\*") or event\_name matches("Update\*") or event\_name matches("Upload\*")<br />\| where event\_source matches("\*iam.amazonaws.com\*")<br />\| count by user\_name,acc\_id,user\_identity\_type,event\_source,event\_type,event\_time,event\_name,aws\_region<br />\| top 100 user\_name,acc\_id,user\_identity\_type,event\_source,event\_type,event\_time,event\_name,aws\_region by event\_time|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|IAM Policy Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* <br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("Add\*") or event.action matches("Attach\*") or event.action matches("Change\*") or event.action matches("Create\*") or event.action matches("Deactivate\*") or event.action matches("Delete\*") or event.action matches("Detach\*") or event.action matches("Enable\*") or event.action matches("Put\*") or event.action matches("Remove\*") or event.action matches("Set\*") or event.action matches("Update\*") or event.action matches("Upload\*")<br />\| where cloud.service.name matches("\*iam\*")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|IAM Policy Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* <br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("Add\*") or event.action matches("Attach\*") or event.action matches("Change\*") or event.action matches("Create\*") or event.action matches("Deactivate\*") or event.action matches("Delete\*") or event.action matches("Detach\*") or event.action matches("Enable\*") or event.action matches("Put\*") or event.action matches("Remove\*") or event.action matches("Set\*") or event.action matches("Update\*") or event.action matches("Upload\*")<br />\| where cloud.service.name matches("\*iam\*")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|IAM Policy Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* <br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("Add\*") or event.action matches("Attach\*") or event.action matches("Change\*") or event.action matches("Create\*") or event.action matches("Deactivate\*") or event.action matches("Delete\*") or event.action matches("Detach\*") or event.action matches("Enable\*") or event.action matches("Put\*") or event.action matches("Remove\*") or event.action matches("Set\*") or event.action matches("Update\*") or event.action matches("Upload\*")<br />\| where cloud.service.name matches("\*iam\*")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Impossible Travel Events|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity|\_sourceCategory=\*CloudTrail\*<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />// filter and sort the data<br />\| where isValidIPv4(client.ip) or isValidIPv6(client.ip)<br />\| where !isNull(client.ip)<br />\| if(isValidIPv4(client.ip), if(!isPrivateIP(client.ip),true,false),true) as is\_public<br />\| where is\_public<br />\| where !isNull(user.name)<br /><br />\| min(\_messagetime) AS login\_time BY user.name,client.ip<br />\| sort by user.name, +login\_time<br />//\| Next, find the previous IP address where each user logged in from, and the previous login time.<br />\| ipv4ToNumber(client.ip) AS ip\_decimal<br />\| backshift ip\_decimal BY user.name<br />\| backshift login\_time AS previous\_login<br />\| where !(isNull(\_backshift))<br />//\| Next, well convert the IP addresses that are in a decimal format to the standard IP address using octets.<br />\| toInt(floor(\_backshift/pow(256, 3))) AS octet1<br />\| toInt(floor((\_backshift-octet1\*pow(256, 3))/pow(256, 2))) AS octet2<br />\| toInt(floor((\_backshift-(octet1\*pow(256, 3)+octet2\*pow(256, 2)))/256)) AS octet3<br />\| toInt(\_backshift-(octet1\*pow(256, 3)+octet2\*pow(256, 2)+octet3\*256)) AS octet4<br />\| concat(octet1,".",octet2,".",octet3,".",octet4) AS previous\_ip<br />//\| Now that we have two different IP addresses, we can use geo lookup on both to find our where each occurred.<br />\| lookup latitude AS lat1, longitude AS long1, country\_name AS country\_name1 FROM geo://location ON ip=client.ip<br />\| lookup latitude AS lat2, longitude AS long2, country\_name AS country\_name2 FROM geo://location ON ip=previous\_ip<br />//\| Now that we have two geolocations from two successive logins, we can calculate the distance between them using the Haversine function<br />\| haversine(lat1, long1, lat2, long2) AS distance\_kms<br />//\| Calculate the speed someone would need to travel that distance in the time between the two logins<br />\| (login\_time - previous\_login)/3600000 AS login\_time\_delta\_hrs<br />\| where login\_time\_delta\_hrs \> 0<br />\| distance\_kms/login\_time\_delta\_hrs AS apparent\_velocity\_kph<br />\| where apparent\_velocity\_kph \> 0<br />//\| Flag certain speeds as suspicious.<br />\| 500 AS suspicious\_speed<br />\| where apparent\_velocity\_kph \> suspicious\_speed<br />//\| add some formatting to clean up the results and make them more human-readable. Add these lines to your query:<br />\| concat(client.ip,", ",previous\_ip) AS ip\_addresses<br />\| if(country\_name1 \<\> country\_name2, concat(country\_name1, ", ", country\_name2), country\_name1) AS countries<br />\| where apparent\_velocity\_kph != "Infinity"<br /><br />\| sort by apparent\_velocity\_kph<br />\| fields user.name, ip\_addresses, countries, distance\_kms, login\_time\_delta\_hrs<br />\| max(distance\_kms) as distance by user.name, ip\_addresses, countries, login\_time\_delta\_hrs<br />\| sort by distance desc<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Impossible Travel Events|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\*<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />// filter and sort the data<br />\| where isValidIPv4(client.ip) or isValidIPv6(client.ip)<br />\| where !isNull(client.ip)<br />\| if(isValidIPv4(client.ip), if(!isPrivateIP(client.ip),true,false),true) as is\_public<br />\| where is\_public<br />\| where !isNull(user.name)<br /><br />\| min(\_messagetime) AS login\_time BY user.name,client.ip<br />\| sort by user.name, +login\_time<br />//\| Next, find the previous IP address where each user logged in from, and the previous login time.<br />\| ipv4ToNumber(client.ip) AS ip\_decimal<br />\| backshift ip\_decimal BY user.name<br />\| backshift login\_time AS previous\_login<br />\| where !(isNull(\_backshift))<br />//\| Next, well convert the IP addresses that are in a decimal format to the standard IP address using octets.<br />\| toInt(floor(\_backshift/pow(256, 3))) AS octet1<br />\| toInt(floor((\_backshift-octet1\*pow(256, 3))/pow(256, 2))) AS octet2<br />\| toInt(floor((\_backshift-(octet1\*pow(256, 3)+octet2\*pow(256, 2)))/256)) AS octet3<br />\| toInt(\_backshift-(octet1\*pow(256, 3)+octet2\*pow(256, 2)+octet3\*256)) AS octet4<br />\| concat(octet1,".",octet2,".",octet3,".",octet4) AS previous\_ip<br />//\| Now that we have two different IP addresses, we can use geo lookup on both to find our where each occurred.<br />\| lookup latitude AS lat1, longitude AS long1, country\_name AS country\_name1 FROM geo://location ON ip=client.ip<br />\| lookup latitude AS lat2, longitude AS long2, country\_name AS country\_name2 FROM geo://location ON ip=previous\_ip<br />//\| Now that we have two geolocations from two successive logins, we can calculate the distance between them using the Haversine function<br />\| haversine(lat1, long1, lat2, long2) AS distance\_kms<br />//\| Calculate the speed someone would need to travel that distance in the time between the two logins<br />\| (login\_time - previous\_login)/3600000 AS login\_time\_delta\_hrs<br />\| where login\_time\_delta\_hrs \> 0<br />\| distance\_kms/login\_time\_delta\_hrs AS apparent\_velocity\_kph<br />\| where apparent\_velocity\_kph \> 0<br />//\| Flag certain speeds as suspicious.<br />\| 500 AS suspicious\_speed<br />\| where apparent\_velocity\_kph \> suspicious\_speed<br />//\| add some formatting to clean up the results and make them more human-readable. Add these lines to your query:<br />\| concat(client.ip,", ",previous\_ip) AS ip\_addresses<br />\| if(country\_name1 \<\> country\_name2, concat(country\_name1, ", ", country\_name2), country\_name1) AS countries<br />\| where apparent\_velocity\_kph != "Infinity"<br /><br />\| sort by apparent\_velocity\_kph<br />\| fields user.name, ip\_addresses, countries, distance\_kms, login\_time\_delta\_hrs<br />\| max(distance\_kms) as distance by user.name, ip\_addresses, countries, login\_time\_delta\_hrs<br />\| sort by distance desc<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Impossible Travel Events|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity|\_sourceCategory=\*CloudTrail\*<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />// filter and sort the data<br />\| where isValidIPv4(client.ip) or isValidIPv6(client.ip)<br />\| where !isNull(client.ip)<br />\| if(isValidIPv4(client.ip), if(!isPrivateIP(client.ip),true,false),true) as is\_public<br />\| where is\_public<br />\| where !isNull(user.name)<br /><br />\| min(\_messagetime) AS login\_time BY user.name,client.ip<br />\| sort by user.name, +login\_time<br />//\| Next, find the previous IP address where each user logged in from, and the previous login time.<br />\| ipv4ToNumber(client.ip) AS ip\_decimal<br />\| backshift ip\_decimal BY user.name<br />\| backshift login\_time AS previous\_login<br />\| where !(isNull(\_backshift))<br />//\| Next, well convert the IP addresses that are in a decimal format to the standard IP address using octets.<br />\| toInt(floor(\_backshift/pow(256, 3))) AS octet1<br />\| toInt(floor((\_backshift-octet1\*pow(256, 3))/pow(256, 2))) AS octet2<br />\| toInt(floor((\_backshift-(octet1\*pow(256, 3)+octet2\*pow(256, 2)))/256)) AS octet3<br />\| toInt(\_backshift-(octet1\*pow(256, 3)+octet2\*pow(256, 2)+octet3\*256)) AS octet4<br />\| concat(octet1,".",octet2,".",octet3,".",octet4) AS previous\_ip<br />//\| Now that we have two different IP addresses, we can use geo lookup on both to find our where each occurred.<br />\| lookup latitude AS lat1, longitude AS long1, country\_name AS country\_name1 FROM geo://location ON ip=client.ip<br />\| lookup latitude AS lat2, longitude AS long2, country\_name AS country\_name2 FROM geo://location ON ip=previous\_ip<br />//\| Now that we have two geolocations from two successive logins, we can calculate the distance between them using the Haversine function<br />\| haversine(lat1, long1, lat2, long2) AS distance\_kms<br />//\| Calculate the speed someone would need to travel that distance in the time between the two logins<br />\| (login\_time - previous\_login)/3600000 AS login\_time\_delta\_hrs<br />\| where login\_time\_delta\_hrs \> 0<br />\| distance\_kms/login\_time\_delta\_hrs AS apparent\_velocity\_kph<br />\| where apparent\_velocity\_kph \> 0<br />//\| Flag certain speeds as suspicious.<br />\| 500 AS suspicious\_speed<br />\| where apparent\_velocity\_kph \> suspicious\_speed<br />//\| add some formatting to clean up the results and make them more human-readable. Add these lines to your query:<br />\| concat(client.ip,", ",previous\_ip) AS ip\_addresses<br />\| if(country\_name1 \<\> country\_name2, concat(country\_name1, ", ", country\_name2), country\_name1) AS countries<br />\| where apparent\_velocity\_kph != "Infinity"<br /><br />\| sort by apparent\_velocity\_kph<br />\| fields user.name, ip\_addresses, countries, distance\_kms, login\_time\_delta\_hrs<br />\| max(distance\_kms) as distance by user.name, ip\_addresses, countries, login\_time\_delta\_hrs<br />\| sort by distance desc|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches|Least Common Out of Compliance Findings|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Least Common Out of Compliance Findings|\_sourceCategory=Labs/AWS/SecurityHub <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName" as account\_id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName nodrop<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, "Informational", "Others") as severity<br />\| if (severity\_normalized \<= 39, "Low", severity) as severity<br />\| if ((severity\_normalized \<= 69) and (severity\_normalized \>= 40), "Medium", severity) as severity<br />\| if ((severity\_normalized \<= 89) and (severity\_normalized \>= 70), "High", severity) as severity<br />\| if (severity\_normalized \<= 100 and severity\_normalized \>= 90, "Critical", severity) as severity<br /><br />// global filters<br />\| where account\_id matches "\*"<br />\| where finding\_id matches "\*"<br />\| where finding\_type matches "\*"<br />\| where finding\_provider matches "\*"<br />\| where severity matches "\*"<br />\| where compliance\_status matches "\*"<br /><br />\| where !isBlank(compliance\_status) and compliance\_status matches "FAILED"<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| timeslice 1h<br />\| count as frequency by finding\_type<br />\| sort by frequency asc<br />\| limit 50|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches|Most Common Out of Compliance Findings|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Most Common Out of Compliance Findings|\_sourceCategory=Labs/AWS/SecurityHub <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName" as account\_id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName nodrop<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, "Informational", "Others") as severity<br />\| if (severity\_normalized \<= 39, "Low", severity) as severity<br />\| if ((severity\_normalized \<= 69) and (severity\_normalized \>= 40), "Medium", severity) as severity<br />\| if ((severity\_normalized \<= 89) and (severity\_normalized \>= 70), "High", severity) as severity<br />\| if (severity\_normalized \<= 100 and severity\_normalized \>= 90, "Critical", severity) as severity<br /><br />// global filters<br />\| where account\_id matches "\*"<br />\| where finding\_id matches "\*"<br />\| where finding\_type matches "\*"<br />\| where finding\_provider matches "\*"<br />\| where severity matches "\*"<br />\| where compliance\_status matches "\*"<br /><br />\| where !isBlank(compliance\_status) and compliance\_status matches "FAILED"<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| timeslice 1h<br />\| count as frequency by finding\_type<br />\| sort by frequency<br />\| limit 50|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Network ACL Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("CreateNetworkAcl" or "CreateNetworkAclEntry" or "DeleteNetworkAcl" or "DeleteNetworkAclEntry" or "ReplaceNetworkAclEntry" or "ReplaceNetworkAclAssociation")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateNetworkAcl" or event.action matches "CreateNetworkAclEntry" or event.action matches "DeleteNetworkAcl" or event.action matches "DeleteNetworkAclEntry" or event.action matches "ReplaceNetworkAclEntry" or event.action matches "ReplaceNetworkAclAssociation"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Network ACL Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("CreateNetworkAcl" or "CreateNetworkAclEntry" or "DeleteNetworkAcl" or "DeleteNetworkAclEntry" or "ReplaceNetworkAclEntry" or "ReplaceNetworkAclAssociation")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateNetworkAcl" or event.action matches "CreateNetworkAclEntry" or event.action matches "DeleteNetworkAcl" or event.action matches "DeleteNetworkAclEntry" or event.action matches "ReplaceNetworkAclEntry" or event.action matches "ReplaceNetworkAclAssociation"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Network ACL Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* ("CreateNetworkAcl" or "CreateNetworkAclEntry" or "DeleteNetworkAcl" or "DeleteNetworkAclEntry" or "ReplaceNetworkAclEntry" or "ReplaceNetworkAclAssociation")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateNetworkAcl" or event.action matches "CreateNetworkAclEntry" or event.action matches "DeleteNetworkAcl" or event.action matches "DeleteNetworkAclEntry" or event.action matches "ReplaceNetworkAclEntry" or event.action matches "ReplaceNetworkAclAssociation"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches|Network ACL Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Network ACL Changes|\_sourceCategory=\*CloudTrail\* ("CreateNetworkAcl" or "CreateNetworkAclEntry" or "DeleteNetworkAcl" or "DeleteNetworkAclEntry" or "ReplaceNetworkAclEntry" or "ReplaceNetworkAclAssociation")<br />\| json "requestID","eventID","userIdentity.sessionContext.sessionIssuer.userName","userIdentity.accountId","sourceIPAddress","awsRegion","eventName","eventType" as request\_id, event\_id,user\_name,acc\_id,source\_ip,region,event\_name,event\_type nodrop<br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where eventName matches "CreateNetworkAcl" or eventName matches "CreateNetworkAclEntry" or eventName matches "DeleteNetworkAcl" or eventName matches "DeleteNetworkAclEntry" or eventName matches "ReplaceNetworkAclEntry" or eventName matches "ReplaceNetworkAclAssociation"<br />\| count as frequency by user\_name,acc\_id<br />\| sort by frequency<br />\| limit 100|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches|New Admins Added|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/New Admins Added|\_sourceCategory=\*CloudTrail\*<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage","requestParameters.policyArn","requestParameters.groupName" as event\_name,source\_ip,user\_name,user\_principal, login\_result,mfa\_used,event\_source,aws\_region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,acc\_id,error\_message,policy\_arn,group\_name nodrop<br />\| if(user\_name = "",user\_principal,user\_name) as user\_name<br /><br />// global filters<br />\| where aws\_region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where event\_name matches("\*AddUserToGroup\*")<br />\| where group\_name matches("\*admin\*")<br /><br />\| count by acc\_id,event\_type,event\_time,event\_source,aws\_region<br />\| sort by event\_time<br />\| limit 100<br />\| fields - \_count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Permissive S3 Buckets Created|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* ("PutBucketAcl" or "\*FULL\_CONTROL\*")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("PutBucketAcl")<br />\| where permission matches("\*FULL\_CONTROL\*")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Permissive S3 Buckets Created|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("PutBucketAcl" or "\*FULL\_CONTROL\*")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("PutBucketAcl")<br />\| where permission matches("\*FULL\_CONTROL\*")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Permissive S3 Buckets Created|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("PutBucketAcl" or "\*FULL\_CONTROL\*")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches("PutBucketAcl")<br />\| where permission matches("\*FULL\_CONTROL\*")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Root Account Logins|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity|\_sourceCategory=\*CloudTrail\* "Root"<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where user\_identity\_type="Root"<br />\| where !isBlank(user.name)<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Root Account Logins|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* "Root"<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where user\_identity\_type="Root"<br />\| where !isBlank(user.name)<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Root Account Logins|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity|\_sourceCategory=\*CloudTrail\* "Root"<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where user\_identity\_type="Root"<br />\| where !isBlank(user.name)<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Route Table Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("CreateRoute" or "CreateRouteTable" or "ReplaceRoute" or "ReplaceRouteTableAssociation" or "DeleteRouteTable" or "DeleteRoute" or "DisassociateRouteTable")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateRoute" or event.action matches "CreateRouteTable" or event.action matches "ReplaceRoute" or event.action matches "ReplaceRouteTableAssociation" or event.action matches "DeleteRouteTable" or event.action matches "DeleteRoute" or event.action matches "DisassociateRouteTable"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Route Table Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("CreateRoute" or "CreateRouteTable" or "ReplaceRoute" or "ReplaceRouteTableAssociation" or "DeleteRouteTable" or "DeleteRoute" or "DisassociateRouteTable")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateRoute" or event.action matches "CreateRouteTable" or event.action matches "ReplaceRoute" or event.action matches "ReplaceRouteTableAssociation" or event.action matches "DeleteRouteTable" or event.action matches "DeleteRoute" or event.action matches "DisassociateRouteTable"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches|Route Table Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Route Table Changes|\_sourceCategory=\*CloudTrail\* ("CreateRoute" or "CreateRouteTable" or "ReplaceRoute" or "ReplaceRouteTableAssociation" or "DeleteRouteTable" or "DeleteRoute" or "DisassociateRouteTable")<br />\| json "requestID","eventID","userIdentity.sessionContext.sessionIssuer.userName","userIdentity.accountId","sourceIPAddress","awsRegion","eventName","eventType" as request\_id, event\_id,user\_name,acc\_id,source\_ip,region,event\_name,event\_type nodrop<br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where eventName matches "CreateRoute" or eventName matches "CreateRouteTable" or eventName matches "ReplaceRoute" or eventName matches "ReplaceRouteTableAssociation" or eventName matches "DeleteRouteTable" or eventName matches "DeleteRoute" or eventName matches "DisassociateRouteTable"<br /><br />\| count as frequency by user\_name,acc\_id<br />\| sort by frequency<br />\| limit 100|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Route Table Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* ("CreateRoute" or "CreateRouteTable" or "ReplaceRoute" or "ReplaceRouteTableAssociation" or "DeleteRouteTable" or "DeleteRoute" or "DisassociateRouteTable")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateRoute" or event.action matches "CreateRouteTable" or event.action matches "ReplaceRoute" or event.action matches "ReplaceRouteTableAssociation" or event.action matches "DeleteRouteTable" or event.action matches "DeleteRoute" or event.action matches "DisassociateRouteTable"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches|S3 Bucket Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/S3 Bucket Changes|\_sourceCategory=\*CloudTrail\* (\*BucketAcl or \*BucketPolicy or \*BucketCors or \*BucketLifecycle)<br />\| json "requestID","eventID","userIdentity.sessionContext.sessionIssuer.userName","userIdentity.accountId","sourceIPAddress","awsRegion","eventName","eventType" as request\_id, event\_id,user\_name,acc\_id,source\_ip,region,event\_name,event\_type nodrop<br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where eventName matches "\*BucketAcl" or eventName matches "\*BucketPolicy" or eventName matches "\*BucketCors" or eventName matches "\*BucketLifecycle"<br />\| count as frequency by user\_name,acc\_id<br />\| sort by frequency<br />\| limit 100|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|S3 Bucket Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* (\*BucketAcl or \*BucketPolicy or \*BucketCors or \*BucketLifecycle)<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "\*BucketAcl" or event.action matches "\*BucketPolicy" or event.action matches "\*BucketCors" or event.action matches "\*BucketLifecycle"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|S3 Bucket Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* (\*BucketAcl or \*BucketPolicy or \*BucketCors or \*BucketLifecycle)<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "\*BucketAcl" or event.action matches "\*BucketPolicy" or event.action matches "\*BucketCors" or event.action matches "\*BucketLifecycle"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|S3 Bucket Permission Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* (\*BucketAcl or \*BucketPolicy or \*BucketCors or \*BucketLifecycle)<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "\*BucketAcl" or event.action matches "\*BucketPolicy" or event.action matches "\*BucketCors" or event.action matches "\*BucketLifecycle"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Security Control Failures|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=Labs/AWS/SecurityHub <br />\| json field=\_raw "AwsAccountId", "Id", "GeneratorId", "ProductArn", "CreatedAt", "UpdatedAt", "Resources", "Severity.Normalized", "SourceUrl", "Title","Types", "Compliance.Status", "vpcId", "subnetId", "groupId" , "tags", "groupName", "Resources[0].Details.AwsIamAccessKey.UserName" as cloud.account.id, finding\_id, generator\_id, product\_arn, created\_at, updated\_at, resources, severity\_normalized, sourceurl, title, finding\_types, compliance\_status ,vpcId, subnetId , securityGroupId, tags, securityGroupName, user.name nodrop<br /><br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />\| topk(1, updated\_at) by finding\_id<br />\| parse regex field=finding\_types "\\"(?\<finding\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Type\\":\\"(?\<resource\_type\>.\*?)\\"" multi<br />\| parse regex field=resources "\\"Id\\":\\"(?\<resource\_id\>.\*?)\\"" multi<br />\| parse regex field=product\_arn "product/(?\<finding\_provider\>.\*?)\$"<br />\| parse regex field=product\_arn ":(?\<sechub\_region\>[a-z]\*-[a-z]\*-\\d{1}):"<br />\| parse field=finding\_type "\*/\*/\*" as namespace, category, classifier<br />\| replace(finding\_type,"\\\\","") as finding\_type<br />\| replace(namespace,"\\\\","") as namespace<br />\| replace(category,"\\\\","") as category<br />\| replace(classifier,"\\\\","") as classifier<br /><br />\| if (severity\_normalized == 0, 0, 0) as risk.static\_level<br />\| if (severity\_normalized \> 0 and severity\_normalized \<= 40, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 40 and severity\_normalized \<= 70, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 70 and severity\_normalized \<= 90, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_normalized \> 90 and severity\_normalized \<= 100, 3, risk.static\_level) as risk.static\_level<br /><br />\| parse field=finding\_type "\*/\*/\*" as rule.ruleset, rule.category, rule.name<br /><br />\| resource\_type as cloud.service.name<br />\| resource\_id as cloud.instance.id<br />\| sechub\_region as cloud.region<br /><br />// global filters<br />\| where if("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />// client.ip,source.user filter is not applicable<br /><br />\| where compliance\_status matches "FAILED"<br />\| topk(1, updated\_at) by finding\_id<br />\| count (finding\_id)|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches|Security Group Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/Security Group Changes|\_sourceCategory=\*CloudTrail\* ("CreateSecurityGroup" or "DeleteSecurityGroup" or "RevokeSecurityGroupEgress" or "RevokeSecurityGroupIngress")<br />\| json "requestID","eventID","userIdentity.sessionContext.sessionIssuer.userName","userIdentity.accountId","sourceIPAddress","awsRegion","eventName","eventType" as request\_id, event\_id,user\_name,acc\_id,source\_ip,region,event\_name,event\_type nodrop<br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where eventName matches "CreateSecurityGroup" or eventName matches "DeleteSecurityGroup" or eventName matches "RevokeSecurityGroupEgress" or eventName matches "RevokeSecurityGroupIngress"<br />\| count as frequency by user\_name,acc\_id<br />\| sort by frequency<br />\| limit 100|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Security Group Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("CreateSecurityGroup" or "DeleteSecurityGroup" or "RevokeSecurityGroupEgress" or "RevokeSecurityGroupIngress")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateSecurityGroup" or event.action matches "DeleteSecurityGroup" or event.action matches "RevokeSecurityGroupEgress" or event.action matches "RevokeSecurityGroupIngress"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Security Group Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("CreateSecurityGroup" or "DeleteSecurityGroup" or "RevokeSecurityGroupEgress" or "RevokeSecurityGroupIngress")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateSecurityGroup" or event.action matches "DeleteSecurityGroup" or event.action matches "RevokeSecurityGroupEgress" or event.action matches "RevokeSecurityGroupIngress"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Security Group Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* ("CreateSecurityGroup" or "DeleteSecurityGroup" or "RevokeSecurityGroupEgress" or "RevokeSecurityGroupIngress")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateSecurityGroup" or event.action matches "DeleteSecurityGroup" or event.action matches "RevokeSecurityGroupEgress" or event.action matches "RevokeSecurityGroupIngress"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Suspicious Blocked Destinations by Location|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity|\_sourceCategory=PDET/CIS/AWS/Vanta/Flow <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "alert" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, alert nodrop<br />\| where event.type="alert"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br /><br />\| lookup latitude, longitude, country\_code, country\_name, region, city, postal\_code from geo://location on ip = client.ip<br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="blocked",1,0) as Blocked\_count<br />\| if(event.outcome="allowed",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, server.ip, client.ip, latitude, longitude, country\_code<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by server.ip, client.ip, latitude, longitude, country\_code<br />\| smooth eventCount as eventCount\_mean by server.ip, client.ip, latitude, longitude, country\_code<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by server.ip, client.ip, latitude, longitude, country\_code<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count as event\_location by latitude, longitude<br />\| sort by event\_location|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Suspicious Blocked Source-Destination Pairs|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity|\_sourceCategory=PDET/CIS/AWS/Vanta/Flow <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "alert" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, alert nodrop<br />\| where event.type="alert"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="blocked",1,0) as Blocked\_count<br />\| if(event.outcome="allowed",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, server.ip, client.ip<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by server.ip, client.ip<br />\| smooth eventCount as eventCount\_mean by server.ip, client.ip<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by server.ip, client.ip<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Suspicious Blocked Source-Destination Pairs|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity|\_sourceCategory=PDET/CIS/AWS/Vanta/Flow <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "alert" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, alert nodrop<br />\| where event.type="alert"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="blocked",1,0) as Blocked\_count<br />\| if(event.outcome="allowed",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, server.ip, client.ip<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by server.ip, client.ip<br />\| smooth eventCount as eventCount\_mean by server.ip, client.ip<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by server.ip, client.ip<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Suspicious Blocked Source-Destination Pairs|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=PDET/CIS/AWS/Vanta/Flow <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "alert" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, alert nodrop<br />\| where event.type="alert"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br /><br />// filters<br />\| where if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="blocked",1,0) as Blocked\_count<br />\| if(event.outcome="allowed",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, server.ip, client.ip<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by server.ip, client.ip<br />\| smooth eventCount as eventCount\_mean by server.ip, client.ip<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by server.ip, client.ip<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Suspicious Blocked Web Requests|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Web Activity|\_sourceCategory=Labs/AWS/WAF <br />\| json "httpRequest.httpMethod","httpRequest.httpVersion","httpRequest.uri","httpRequest.clientIp","httpRequest.country","action","matchingNonTerminatingRules","rateBasedRuleList","ruleGroupList","httpSourceId","httpSourceName","terminatingRuleType","terminatingRuleId","webaclId" as event.action,http\_version,url.path,client.ip,country,event.outcome,matching\_non\_terminating\_rules,rate\_based\_rule\_list,rule\_group\_list,http\_source\_id,http\_source\_name,terminating\_rule\_type,terminating\_rule\_id,webacl\_id nodrop<br /><br />\| lookup latitude, longitude, country\_code, country\_name, region, city, postal\_code from geo://location on ip = client.ip<br /><br />// global filters<br />\| where if ("{{url.path}}" = "\*", true, url.path matches "{{url.path}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{event.outcome}}" = "\*", true, event.outcome matches "{{event.outcome}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="BLOCK",1,0) as Blocked\_count<br />\| if(event.outcome="ALLOW",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, client.ip,url.path, terminating\_rule\_type,terminating\_rule\_id,event.action,http\_source\_id,http\_source\_name, latitude, longitude, country\_code<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| smooth eventCount as eventCount\_mean by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Suspicious Blocked Web Requests|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Web Activity|\_sourceCategory=Labs/AWS/WAF <br />\| json "httpRequest.httpMethod","httpRequest.httpVersion","httpRequest.uri","httpRequest.clientIp","httpRequest.country","action","matchingNonTerminatingRules","rateBasedRuleList","ruleGroupList","httpSourceId","httpSourceName","terminatingRuleType","terminatingRuleId","webaclId" as event.action,http\_version,url.path,client.ip,country,event.outcome,matching\_non\_terminating\_rules,rate\_based\_rule\_list,rule\_group\_list,http\_source\_id,http\_source\_name,terminating\_rule\_type,terminating\_rule\_id,webacl\_id nodrop<br /><br />\| lookup latitude, longitude, country\_code, country\_name, region, city, postal\_code from geo://location on ip = client.ip<br /><br />// global filters<br />\| where if ("{{url.path}}" = "\*", true, url.path matches "{{url.path}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{event.outcome}}" = "\*", true, event.outcome matches "{{event.outcome}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="BLOCK",1,0) as Blocked\_count<br />\| if(event.outcome="ALLOW",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, client.ip,url.path, terminating\_rule\_type,terminating\_rule\_id,event.action,http\_source\_id,http\_source\_name, latitude, longitude, country\_code<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| smooth eventCount as eventCount\_mean by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Suspicious Blocked Web Requests|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=Labs/AWS/WAF <br />\| json "httpRequest.httpMethod","httpRequest.httpVersion","httpRequest.uri","httpRequest.clientIp","httpRequest.country","action","matchingNonTerminatingRules","rateBasedRuleList","ruleGroupList","httpSourceId","httpSourceName","terminatingRuleType","terminatingRuleId","webaclId" as event.action,http\_version,url.path,client.ip,country,event.outcome,matching\_non\_terminating\_rules,rate\_based\_rule\_list,rule\_group\_list,http\_source\_id,http\_source\_name,terminating\_rule\_type,terminating\_rule\_id,webacl\_id nodrop<br /><br />\| lookup latitude, longitude, country\_code, country\_name, region, city, postal\_code from geo://location on ip = client.ip<br /><br />// global filters<br />\| where if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") <br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="BLOCK",1,0) as Blocked\_count<br />\| if(event.outcome="ALLOW",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, client.ip,url.path, terminating\_rule\_type,terminating\_rule\_id,event.action,http\_source\_id,http\_source\_name, latitude, longitude, country\_code<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| smooth eventCount as eventCount\_mean by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Suspicious Blocked Web Requests by Location|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Web Activity|\_sourceCategory=Labs/AWS/WAF <br />\| json "httpRequest.httpMethod","httpRequest.httpVersion","httpRequest.uri","httpRequest.clientIp","httpRequest.country","action","matchingNonTerminatingRules","rateBasedRuleList","ruleGroupList","httpSourceId","httpSourceName","terminatingRuleType","terminatingRuleId","webaclId" as event.action,http\_version,url.path,client.ip,country,event.outcome,matching\_non\_terminating\_rules,rate\_based\_rule\_list,rule\_group\_list,http\_source\_id,http\_source\_name,terminating\_rule\_type,terminating\_rule\_id,webacl\_id nodrop<br /><br />\| lookup latitude, longitude, country\_code, country\_name, region, city, postal\_code from geo://location on ip = client.ip<br /><br />// global filters<br />\| where if ("{{url.path}}" = "\*", true, url.path matches "{{url.path}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{event.outcome}}" = "\*", true, event.outcome matches "{{event.outcome}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="BLOCK",1,0) as Blocked\_count<br />\| if(event.outcome="ALLOW",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, client.ip,url.path, terminating\_rule\_type,terminating\_rule\_id,event.action,http\_source\_id,http\_source\_name, latitude, longitude, country\_code<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| smooth eventCount as eventCount\_mean by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip,url.path,event.action,http\_source\_id,http\_source\_name,latitude,longitude,country\_code<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count as event\_location by latitude, longitude<br />\| sort by event\_location|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Suspicious Destinations by Traffic (Megabytes)|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity|\_sourceCategory=PDET/CIS/AWS/Vanta/Flow <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "app\_proto", "netflow" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, app\_proto, netflow nodrop<br />\| where event.type="netflow"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br />\| json field=netflow "bytes", "pkts" as network.bytes, packets nodrop<br /><br />\| lookup latitude, longitude, country\_code, country\_name, region, city, postal\_code from geo://location on ip = client.ip <br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| network.bytes/1Mi as m\_bytes<br />\| sum(m\_bytes) as total\_mega\_bytes by \_timeslice, server.ip, client.ip, latitude, longitude, country\_code<br />\| total\_mega\_bytes as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by server.ip, client.ip, latitude, longitude, country\_code<br />\| smooth eventCount as eventCount\_mean by server.ip, client.ip, latitude, longitude, country\_code <br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by server.ip, client.ip, latitude, longitude, country\_code<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count as event\_location by latitude, longitude<br />\| sort by event\_location|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Suspicious Megabytes Source-Destination Pairs|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity|\_sourceCategory=PDET/CIS/AWS/Vanta/Flow <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "app\_proto", "netflow" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, app\_proto, netflow nodrop<br />\| where event.type="netflow"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br />\| json field=netflow "bytes", "pkts" as network.bytes, packets nodrop<br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| network.bytes/1Mi as m\_bytes<br />\| sum(m\_bytes) as total\_mega\_bytes by \_timeslice, server.ip, client.ip<br />\| total\_mega\_bytes as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by server.ip, client.ip<br />\| smooth eventCount as eventCount\_mean by server.ip, client.ip<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by server.ip, client.ip<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Suspicious Traffic (Megabytes)|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity|\_sourceCategory=PDET/CIS/AWS/Vanta/Flow <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "app\_proto", "netflow" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, app\_proto, netflow nodrop<br />\| where event.type="netflow"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br />\| json field=netflow "bytes", "pkts" as network.bytes, packets nodrop<br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| network.bytes/1Mi as m\_bytes<br />\| sum(m\_bytes) as total\_mega\_bytes by \_timeslice, server.ip, client.ip<br />\| total\_mega\_bytes as eventCount<br />\| sort + \_timeslice<br /><br />\| rollingstd eventCount as eventCount\_std by server.ip, client.ip<br />\| smooth eventCount as eventCount\_mean by server.ip, client.ip<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by server.ip, client.ip<br />\| round(max\_zscore, 2) as max\_zscore <br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
||Threats by Actor|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Storage|\_sourceCategory=\*CloudTrail\* "s3.amazonaws.com"<br />\| json "userIdentity", "eventTime", "eventSource", "eventName", "awsRegion", "sourceIPAddress", "userAgent", "errorCode", "requestParameters", "eventType" as userIdentity, event\_time, eventSource, event.action, cloud.region, client.ip, user\_agent, event.outcome, requestParameters, eventType nodrop<br />\| where eventSource = "s3.amazonaws.com"<br />\| json field=userIdentity "type", "accountId", "userName" as userType, cloud.account.id, user.name<br />\| json field=requestParameters "bucketName" as cloud.instance.id<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| if (userType matches("IAMUser"), "user", "machine") as event.agent<br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{threat.group.name}}" = "\*", true, actor matches "{{threat.group.name}}") AND if ("{{source.user}}" = "\*", true, source.user matches "{{source.user}}}")<br /><br />\| count by actor<br />\| sort by \_count|
||Threats by Actor|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS APIs|\_sourceCategory=\*CloudTrail\* sourceIPAddress !("s3.amazonaws.com")<br />\| json "eventTime", "eventName", "eventSource", "awsRegion", "sourceIPAddress", "errorCode", "userAgent" as event\_time, event.action, eventSource, cloud.region, client.ip, event.outcome, user\_agent nodrop<br />\| json "userIdentity.userName", "userIdentity.accountId", "userIdentity.type" as user.name, cloud.account.id, user\_identity\_type nodrop<br />\| json field=\_raw "requestParameters.dBInstanceIdentifier", "requestParameters.instancesSet.items[0].instanceId" as db\_instance\_id, cloud\_instance\_id nodrop<br /><br />\| parse "\\"userName\\":\\"\*\\"" as user.name nodrop<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(db\_instance\_id),cloud\_instance\_id,db\_instance\_id) as cloud.instance.id<br />\| if(isEmpty(cloud.instance.id),"NA", cloud.instance.id) as cloud.instance.id<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{event.outcome}}" = "\*", true, event.outcome matches "{{event.outcome}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{threat.group.name}}" = "\*", true, actor matches "{{threat.group.name}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}"))<br /><br />\| json field=raw "malware\_families[\*]" as threat\_malware\_families nodrop<br />\| json field=raw "last\_updated" as last\_updated nodrop<br />\| formatDate(fromseconds(last\_updated), "MM-dd-yyyy") as threat\_last\_updated<br />\| json field=raw "labels[\*].name" as label\_name nodrop<br />\| replace(label\_name, "\\\\/","-\>") as label\_name<br />\| replace(label\_name, "\\""," ") as label\_name<br /><br />\| count by actor, label\_name, risk.static\_level \| sort by \_count, actor, label\_name, risk.static\_level asc|
||Threats by Country|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Resources|\_sourceCategory=PDET/CIS/AWS/GuardDuty (geoLocation and lat and lon)<br />\| json "accountId", "region", "partition", "id", "arn", "type","service.serviceName","service.detectorId","service.action","severity","title","description", "vpcId", "subnetId", "groupId" , "tags", "groupName", "resource.instanceDetails", "resource.accessKeyDetails.userName" as cloud.account.id, cloud.region, partition, id, arn, type, service\_name, detector\_id, action, severity\_level, title, description, vpcId, subnetId , securityGroupId, tags, securityGroupName, instanceDetails, user.name nodrop<br /><br />\| json field=instanceDetails "instanceId", "instanceType","networkInterfaces[0].publicIp" as instanceid, cloud.machine.type, server.ip<br />\| json field=\_raw "resource.resourceType" as resourceType<br />\| json field=\_raw "resource.s3BucketDetails[0].name" as bucketName nodrop<br />\| if (resourceType = "S3Bucket", bucketName, instanceid) as cloud.instance.id<br /><br />\| json field=action "awsApiCallAction.remoteIpDetails.ipAddressV4", "networkConnectionAction.remoteIpDetails.ipAddressV4","networkConnectionAction.localPortDetails.port","networkConnectionAction.remoteIpDetails.geoLocation.lon", "networkConnectionAction.remoteIpDetails.geoLocation.lat", "networkConnectionAction.remoteIpDetails.organization.asnOrg", "networkConnectionAction.remoteIpDetails.organization.org", "networkConnectionAction.remoteIpDetails.organization.isp" as awsCallActionIp, networkActionIp, localPort,longitude, latitude, asnOrg, organization, isp nodrop<br /><br />\| parse field=type "\*:\*/\*" as threat.tactic.name,cloud.service.name,threat.technique.name <br />\| if (severity\_level = 0, 0, 0) as risk.static\_level<br />\| if (severity\_level \> 0 and severity\_level \<= 2, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 2 and severity\_level \<= 5, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 5 and severity\_level \<= 9, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 9, 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(awsCallActionIp), networkActionIp, awsCallActionIp) as client.ip<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{threat.tactic.name}}" = "\*", true, threat.tactic.name matches "{{threat.tactic.name}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}")<br /><br />\| lookup latitude, longitude from geo://location on ip = client.ip<br />\| count by latitude, longitude|
||Threats by Events and Result|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS APIs|\_sourceCategory=\*CloudTrail\* sourceIPAddress !("s3.amazonaws.com")<br />\| json "eventTime", "eventName", "eventSource", "awsRegion", "sourceIPAddress", "errorCode", "userAgent" as event\_time, event.action, eventSource, cloud.region, client.ip, event.outcome, user\_agent nodrop<br />\| json "userIdentity.userName", "userIdentity.accountId", "userIdentity.type" as user.name, cloud.account.id, user\_identity\_type nodrop<br />\| json field=\_raw "requestParameters.dBInstanceIdentifier", "requestParameters.instancesSet.items[0].instanceId" as db\_instance\_id, cloud\_instance\_id nodrop<br /><br />\| parse "\\"userName\\":\\"\*\\"" as user.name nodrop<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(db\_instance\_id),cloud\_instance\_id,db\_instance\_id) as cloud.instance.id<br />\| if(isEmpty(cloud.instance.id),"NA", cloud.instance.id) as cloud.instance.id<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{event.outcome}}" = "\*", true, event.outcome matches "{{event.outcome}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{threat.group.name}}" = "\*", true, actor matches "{{threat.group.name}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}"))<br /><br />\| json field=raw "malware\_families[\*]" as threat\_malware\_families nodrop<br />\| json field=raw "last\_updated" as last\_updated nodrop<br />\| formatDate(fromseconds(last\_updated), "MM-dd-yyyy") as threat\_last\_updated<br />\| json field=raw "labels[\*].name" as label\_name nodrop<br />\| replace(label\_name, "\\\\/","-\>") as label\_name<br />\| replace(label\_name, "\\""," ") as label\_name<br /><br />\| count by event.action, event.outcome<br />\| transpose row event.action column event.outcome|
||Threats by Events and Result|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Storage|\_sourceCategory=\*CloudTrail\* "s3.amazonaws.com"<br />\| json "userIdentity", "eventTime", "eventSource", "eventName", "awsRegion", "sourceIPAddress", "userAgent", "errorCode", "requestParameters", "eventType" as userIdentity, event\_time, eventSource, event.action, cloud.region, client.ip, user\_agent, event.outcome, requestParameters, eventType nodrop<br />\| where eventSource = "s3.amazonaws.com"<br />\| json field=userIdentity "type", "accountId", "userName" as userType, cloud.account.id, user.name<br />\| json field=requestParameters "bucketName" as cloud.instance.id<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| if (userType matches("IAMUser"), "user", "machine") as event.agent<br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{threat.group.name}}" = "\*", true, actor matches "{{threat.group.name}}") AND if ("{{source.user}}" = "\*", true, source.user matches "{{source.user}}}")<br /> <br />\| count by event.action, event.outcome<br />\| transpose row event.action column event.outcome|
||Threats by Geo Location|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS APIs|\_sourceCategory=\*CloudTrail\* sourceIPAddress !("s3.amazonaws.com")<br />\| json "eventTime", "eventName", "eventSource", "awsRegion", "sourceIPAddress", "errorCode", "userAgent" as event\_time, event.action, eventSource, cloud.region, client.ip, event.outcome, user\_agent nodrop<br />\| json "userIdentity.userName", "userIdentity.accountId", "userIdentity.type" as user.name, cloud.account.id, user\_identity\_type nodrop<br />\| json field=\_raw "requestParameters.dBInstanceIdentifier", "requestParameters.instancesSet.items[0].instanceId" as db\_instance\_id, cloud\_instance\_id nodrop<br /><br />\| parse "\\"userName\\":\\"\*\\"" as user.name nodrop<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(db\_instance\_id),cloud\_instance\_id,db\_instance\_id) as cloud.instance.id<br />\| if(isEmpty(cloud.instance.id),"NA", cloud.instance.id) as cloud.instance.id<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{event.outcome}}" = "\*", true, event.outcome matches "{{event.outcome}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{threat.group.name}}" = "\*", true, actor matches "{{threat.group.name}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}"))<br /><br />\| json field=raw "malware\_families[\*]" as threat\_malware\_families nodrop<br />\| json field=raw "last\_updated" as last\_updated nodrop<br />\| formatDate(fromseconds(last\_updated), "MM-dd-yyyy") as threat\_last\_updated<br />\| json field=raw "labels[\*].name" as label\_name nodrop<br />\| replace(label\_name, "\\\\/","-\>") as label\_name<br />\| replace(label\_name, "\\""," ") as label\_name<br /><br />\| lookup latitude, longitude from geo://location on ip = client.ip<br />\| count by latitude, longitude, label\_name, threat\_last\_updated|
||Threats by Geo Location|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Storage|\_sourceCategory=\*CloudTrail\* "s3.amazonaws.com"<br />\| json "userIdentity", "eventTime", "eventSource", "eventName", "awsRegion", "sourceIPAddress", "userAgent", "errorCode", "requestParameters", "eventType" as userIdentity, event\_time, eventSource, event.action, cloud.region, client.ip, user\_agent, event.outcome, requestParameters, eventType nodrop<br />\| where eventSource = "s3.amazonaws.com"<br />\| json field=userIdentity "type", "accountId", "userName" as userType, cloud.account.id, user.name<br />\| json field=requestParameters "bucketName" as cloud.instance.id<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| if (userType matches("IAMUser"), "user", "machine") as event.agent<br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{threat.group.name}}" = "\*", true, actor matches "{{threat.group.name}}") AND if ("{{source.user}}" = "\*", true, source.user matches "{{source.user}}}")<br /><br />\| lookup latitude, longitude from geo://location on ip = client.ip<br />\| count by latitude, longitude|
||Threats by Resource|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Storage|\_sourceCategory=\*CloudTrail\* "s3.amazonaws.com"<br />\| json "userIdentity", "eventTime", "eventSource", "eventName", "awsRegion", "sourceIPAddress", "userAgent", "errorCode", "requestParameters", "eventType" as userIdentity, event\_time, eventSource, event.action, cloud.region, client.ip, user\_agent, event.outcome, requestParameters, eventType nodrop<br />\| where eventSource = "s3.amazonaws.com"<br />\| json field=userIdentity "type", "accountId", "userName" as userType, cloud.account.id, user.name<br />\| json field=requestParameters "bucketName" as cloud.instance.id<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| if (userType matches("IAMUser"), "user", "machine") as event.agent<br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{threat.group.name}}" = "\*", true, actor matches "{{threat.group.name}}") AND if ("{{source.user}}" = "\*", true, source.user matches "{{source.user}}}")<br /><br />\| count by cloud.instance.id, client.ip, user.name, risk.static\_level<br />\| sort by \_count|
||Threats by Resource|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS APIs|\_sourceCategory=\*CloudTrail\* sourceIPAddress !("s3.amazonaws.com")<br />\| json "eventTime", "eventName", "eventSource", "awsRegion", "sourceIPAddress", "errorCode", "userAgent" as event\_time, event.action, eventSource, cloud.region, client.ip, event.outcome, user\_agent nodrop<br />\| json "userIdentity.userName", "userIdentity.accountId", "userIdentity.type" as user.name, cloud.account.id, user\_identity\_type nodrop<br />\| json field=\_raw "requestParameters.dBInstanceIdentifier", "requestParameters.instancesSet.items[0].instanceId" as db\_instance\_id, cloud\_instance\_id nodrop<br /><br />\| parse "\\"userName\\":\\"\*\\"" as user.name nodrop<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(db\_instance\_id),cloud\_instance\_id,db\_instance\_id) as cloud.instance.id<br />\| if(isEmpty(cloud.instance.id),"NA", cloud.instance.id) as cloud.instance.id<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{event.outcome}}" = "\*", true, event.outcome matches "{{event.outcome}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{threat.group.name}}" = "\*", true, actor matches "{{threat.group.name}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}"))<br /><br />\| json field=raw "malware\_families[\*]" as threat\_malware\_families nodrop<br />\| json field=raw "last\_updated" as last\_updated nodrop<br />\| formatDate(fromseconds(last\_updated), "MM-dd-yyyy") as threat\_last\_updated<br />\| json field=raw "labels[\*].name" as label\_name nodrop<br />\| replace(label\_name, "\\\\/","-\>") as label\_name<br />\| replace(label\_name, "\\""," ") as label\_name<br /><br />\| count by client.ip, event.action, user.name, cloud.account.id, cloud.region, cloud.instance.id, cloud.service.name, user\_identity\_type, accessKeyId<br />\| sum(\_count) as total\_threats by client.ip, event.action,user\_identity\_type,user.name,accessKeyId , cloud.account.id, cloud.region, cloud.instance.id, cloud.service.name<br />\| sort by total\_threats|
||Threats Count|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Storage|\_sourceCategory=\*CloudTrail\* "s3.amazonaws.com"<br />\| json "userIdentity", "eventTime", "eventSource", "eventName", "awsRegion", "sourceIPAddress", "userAgent", "errorCode", "requestParameters", "eventType" as userIdentity, event\_time, eventSource, event.action, cloud.region, client.ip, user\_agent, event.outcome, requestParameters, eventType nodrop<br />\| where eventSource = "s3.amazonaws.com"<br />\| json field=userIdentity "type", "accountId", "userName" as userType, cloud.account.id, user.name<br />\| json field=requestParameters "bucketName" as cloud.instance.id<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| if (userType matches("IAMUser"), "user", "machine") as event.agent<br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{threat.group.name}}" = "\*", true, actor matches "{{threat.group.name}}") AND if ("{{source.user}}" = "\*", true, source.user matches "{{source.user}}}")<br /><br />\| count|
||Threats Count|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS APIs|\_sourceCategory=\*CloudTrail\* sourceIPAddress !("s3.amazonaws.com")<br />\| json "eventTime", "eventName", "eventSource", "awsRegion", "sourceIPAddress", "errorCode", "userAgent" as event\_time, event.action, eventSource, cloud.region, client.ip, event.outcome, user\_agent nodrop<br />\| json "userIdentity.userName", "userIdentity.accountId", "userIdentity.type" as user.name, cloud.account.id, user\_identity\_type nodrop<br />\| json field=\_raw "requestParameters.dBInstanceIdentifier", "requestParameters.instancesSet.items[0].instanceId" as db\_instance\_id, cloud\_instance\_id nodrop<br /><br />\| parse "\\"userName\\":\\"\*\\"" as user.name nodrop<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(db\_instance\_id),cloud\_instance\_id,db\_instance\_id) as cloud.instance.id<br />\| if(isEmpty(cloud.instance.id),"NA", cloud.instance.id) as cloud.instance.id<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{event.outcome}}" = "\*", true, event.outcome matches "{{event.outcome}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{threat.group.name}}" = "\*", true, actor matches "{{threat.group.name}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}"))<br /><br />\| json field=raw "malware\_families[\*]" as threat\_malware\_families nodrop<br />\| json field=raw "last\_updated" as last\_updated nodrop<br />\| formatDate(fromseconds(last\_updated), "MM-dd-yyyy") as threat\_last\_updated<br />\| json field=raw "labels[\*].name" as label\_name nodrop<br />\| replace(label\_name, "\\\\/","-\>") as label\_name<br />\| replace(label\_name, "\\""," ") as label\_name<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Threats Count AWS API|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* sourceIPAddress !("s3.amazonaws.com")<br />\| json "eventTime", "eventName", "eventSource", "awsRegion", "sourceIPAddress", "errorCode", "userAgent" as event\_time, event.action, eventSource, cloud.region, client.ip, event.outcome, user\_agent nodrop<br />\| json "userIdentity.userName", "userIdentity.accountId", "userIdentity.type" as user.name, cloud.account.id, user\_identity\_type nodrop<br />\| json field=\_raw "requestParameters.dBInstanceIdentifier", "requestParameters.instancesSet.items[0].instanceId" as db\_instance\_id, cloud\_instance\_id nodrop<br /><br />\| parse "\\"userName\\":\\"\*\\"" as user.name nodrop<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(db\_instance\_id),cloud\_instance\_id,db\_instance\_id) as cloud.instance.id<br />\| if(isEmpty(cloud.instance.id),"NA", cloud.instance.id) as cloud.instance.id<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />//hard coding risk static level for demo purposes only; request from ISHAAN<br /><br />\| where  if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("0"))<br /><br />\| json field=raw "malware\_families[\*]" as threat\_malware\_families nodrop<br />\| json field=raw "last\_updated" as last\_updated nodrop<br />\| formatDate(fromseconds(last\_updated), "MM-dd-yyyy") as threat\_last\_updated<br />\| json field=raw "labels[\*].name" as label\_name nodrop<br />\| replace(label\_name, "\\\\/","-\>") as label\_name<br />\| replace(label\_name, "\\""," ") as label\_name<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Threats Count AWS Resources|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=PDET/CIS/AWS/GuardDuty <br />\| json "accountId", "region", "partition", "id", "arn", "type","service.serviceName","service.detectorId","service.action","severity","title","description", "vpcId", "subnetId", "groupId" , "tags", "groupName", "resource.instanceDetails", "resource.accessKeyDetails.userName" as cloud.account.id, cloud.region, partition, id, arn, type, service\_name, detector\_id, action, severity\_level, title, description, vpcId, subnetId , securityGroupId, tags, securityGroupName, instanceDetails, user.name nodrop<br /><br />\| json field=instanceDetails "instanceId", "instanceType","networkInterfaces[0].publicIp" as instanceid, cloud.machine.type, server.ip<br />\| json field=\_raw "resource.resourceType" as resourceType<br />\| json field=\_raw "resource.s3BucketDetails[0].name" as bucketName nodrop<br />\| if (resourceType = "S3Bucket", bucketName, instanceid) as cloud.instance.id<br /><br />\| json field=action "awsApiCallAction.remoteIpDetails.ipAddressV4", "networkConnectionAction.remoteIpDetails.ipAddressV4","networkConnectionAction.localPortDetails.port" as awsCallActionIp, networkActionIp, localPort nodrop<br /><br />\| parse field=type "\*:\*/\*" as threat.tactic.name,cloud.service.name,threat.technique.name <br />\| if (severity\_level = 0, 0, 0) as risk.static\_level<br />\| if (severity\_level \> 0 and severity\_level \<= 2, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 2 and severity\_level \<= 5, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 5 and severity\_level \<= 9, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 9, 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(awsCallActionIp), if (isEmpty(networkActionIp), "NA",networkActionIp) , awsCallActionIp) as client.ip<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}"))<br />// not filtering on source.user<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Threats Count AWS Storage|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* "s3.amazonaws.com"<br />\| json "userIdentity", "eventTime", "eventSource", "eventName", "awsRegion", "sourceIPAddress", "userAgent", "errorCode", "requestParameters", "eventType" as userIdentity, event\_time, eventSource, event.action, cloud.region, client.ip, user\_agent, event.outcome, requestParameters, eventType nodrop<br />\| where eventSource = "s3.amazonaws.com"<br />\| json field=userIdentity "type", "accountId", "userName" as userType, cloud.account.id, user.name<br />\| json field=requestParameters "bucketName" as cloud.instance.id<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| if (userType matches("IAMUser"), "user", "machine") as event.agent<br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}"))<br /><br />\| count|
||Threats Trend|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Storage|\_sourceCategory=\*CloudTrail\* "s3.amazonaws.com"<br />\| json "userIdentity", "eventTime", "eventSource", "eventName", "awsRegion", "sourceIPAddress", "userAgent", "errorCode", "requestParameters", "eventType" as userIdentity, event\_time, eventSource, event.action, cloud.region, client.ip, user\_agent, event.outcome, requestParameters, eventType nodrop<br />\| where eventSource = "s3.amazonaws.com"<br />\| json field=userIdentity "type", "accountId", "userName" as userType, cloud.account.id, user.name<br />\| json field=requestParameters "bucketName" as cloud.instance.id<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| if (userType matches("IAMUser"), "user", "machine") as event.agent<br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{threat.group.name}}" = "\*", true, actor matches "{{threat.group.name}}") AND if ("{{source.user}}" = "\*", true, source.user matches "{{source.user}}}")<br /><br />\| timeslice 1d<br />\| count by \_timeslice<br />\| fillmissing timeslice|
||Threats Trend|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS APIs|\_sourceCategory=\*CloudTrail\* sourceIPAddress !("s3.amazonaws.com")<br />\| json "eventTime", "eventName", "eventSource", "awsRegion", "sourceIPAddress", "errorCode", "userAgent" as event\_time, event.action, eventSource, cloud.region, client.ip, event.outcome, user\_agent nodrop<br />\| json "userIdentity.userName", "userIdentity.accountId", "userIdentity.type" as user.name, cloud.account.id, user\_identity\_type nodrop<br />\| json field=\_raw "requestParameters.dBInstanceIdentifier", "requestParameters.instancesSet.items[0].instanceId" as db\_instance\_id, cloud\_instance\_id nodrop<br /><br />\| parse "\\"userName\\":\\"\*\\"" as user.name nodrop<br />\| parse field=eventSource "\*." as cloud.service.name<br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br /><br />\| lookup type, actor, raw, threatlevel as malicious\_confidence, threat from sumo://threat/cs on threat=client.ip<br />\| where type="ip\_address"<br /><br />\| if (malicious\_confidence = "low", 1, 0) as risk.static\_level<br />\| if (malicious\_confidence = "medium", 2, risk.static\_level) as risk.static\_level<br />\| if (malicious\_confidence = "high", 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(db\_instance\_id),cloud\_instance\_id,db\_instance\_id) as cloud.instance.id<br />\| if(isEmpty(cloud.instance.id),"NA", cloud.instance.id) as cloud.instance.id<br />\| if (isEmpty(event.outcome), "Success", event.outcome) as event.outcome<br />\| if (isEmpty(user.name), "NA", user.name) as user.name<br />\| if (isEmpty(actor), "Unassigned", actor) as actor<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{event.outcome}}" = "\*", true, event.outcome matches "{{event.outcome}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{threat.group.name}}" = "\*", true, actor matches "{{threat.group.name}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}"))<br /><br />\| json field=raw "malware\_families[\*]" as threat\_malware\_families nodrop<br />\| json field=raw "last\_updated" as last\_updated nodrop<br />\| formatDate(fromseconds(last\_updated), "MM-dd-yyyy") as threat\_last\_updated<br />\| json field=raw "labels[\*].name" as label\_name nodrop<br />\| replace(label\_name, "\\\\/","-\>") as label\_name<br />\| replace(label\_name, "\\""," ") as label\_name<br /><br />\| timeslice 1d<br />\| count by \_timeslice<br />\| fillmissing timeslice|
||Total Findings|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Active Threats: AWS Resources|\_sourceCategory=PDET/CIS/AWS/GuardDuty <br />\| json "accountId", "region", "partition", "id", "arn", "type","service.serviceName","service.detectorId","service.action","severity","title","description", "vpcId", "subnetId", "groupId" , "tags", "groupName", "resource.instanceDetails", "resource.accessKeyDetails.userName" as cloud.account.id, cloud.region, partition, id, arn, type, service\_name, detector\_id, action, severity\_level, title, description, vpcId, subnetId , securityGroupId, tags, securityGroupName, instanceDetails, user.name nodrop<br /><br />\| json field=instanceDetails "instanceId", "instanceType","networkInterfaces[0].publicIp" as instanceid, cloud.machine.type, server.ip<br />\| json field=\_raw "resource.resourceType" as resourceType<br />\| json field=\_raw "resource.s3BucketDetails[0].name" as bucketName nodrop<br />\| if (resourceType = "S3Bucket", bucketName, instanceid) as cloud.instance.id<br /><br />\| json field=action "awsApiCallAction.remoteIpDetails.ipAddressV4", "networkConnectionAction.remoteIpDetails.ipAddressV4","networkConnectionAction.localPortDetails.port" as awsCallActionIp, networkActionIp, localPort nodrop<br /><br />\| parse field=type "\*:\*/\*" as threat.tactic.name,cloud.service.name,threat.technique.name <br />\| if (severity\_level = 0, 0, 0) as risk.static\_level<br />\| if (severity\_level \> 0 and severity\_level \<= 2, 1, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 2 and severity\_level \<= 5, 2, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 5 and severity\_level \<= 9, 3, risk.static\_level) as risk.static\_level<br />\| if (severity\_level \> 9, 3, risk.static\_level) as risk.static\_level<br /><br />// handle empty values<br />\| if(isEmpty(user.name), "NA", user.name) as user.name<br />\| if(isEmpty(awsCallActionIp), if (isEmpty(networkActionIp), "NA",networkActionIp) , awsCallActionIp) as client.ip<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.instance.id}}" = "\*", true, cloud.instance.id matches "{{cloud.instance.id}}") AND if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{risk.static\_level}}" = "\*", true, risk.static\_level \>= toInt("{{risk.static\_level}}")) AND if ("{{threat.tactic.name}}" = "\*", true, threat.tactic.name matches "{{threat.tactic.name}}") AND if ("{{cloud.service.name}}" = "\*", true, cloud.service.name matches "{{cloud.service.name}}") AND if ("{{user.name}}" = "\*", true, user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}")<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Trend: Blocked Activity Percent|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity|\_sourceCategory=PDET/CIS/AWS/Vanta/Flow <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "alert" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, alert nodrop<br />\| where event.type="alert"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="blocked",1,0) as Blocked\_count<br />\| if(event.outcome="allowed",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, server.ip, client.ip<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| avg(eventCount) as avg\_blocked\_pct by \_timeslice|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Trend: Blocked Web Requests Percent|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Web Activity|\_sourceCategory=Labs/AWS/WAF <br />\| json "httpRequest.httpMethod","httpRequest.httpVersion","httpRequest.uri","httpRequest.clientIp","httpRequest.country","action","matchingNonTerminatingRules","rateBasedRuleList","ruleGroupList","httpSourceId","httpSourceName","terminatingRuleType","terminatingRuleId","webaclId" as event.action,http\_version,url.path,client.ip,country,event.outcome,matching\_non\_terminating\_rules,rate\_based\_rule\_list,rule\_group\_list,http\_source\_id,http\_source\_name,terminating\_rule\_type,terminating\_rule\_id,webacl\_id nodrop<br /><br />\| lookup latitude, longitude, country\_code, country\_name, region, city, postal\_code from geo://location on ip = client.ip<br /><br />// global filters<br />\| where if ("{{url.path}}" = "\*", true, url.path matches "{{url.path}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{event.action}}" = "\*", true, event.action matches "{{event.action}}") AND if ("{{event.outcome}}" = "\*", true, event.outcome matches "{{event.outcome}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| if(event.outcome="BLOCK",1,0) as Blocked\_count<br />\| if(event.outcome="ALLOW",1,0) as Allowed\_count<br />\|sum(Blocked\_count) as blocked, sum(Allowed\_count) as allowed by \_timeslice, client.ip,url.path, terminating\_rule\_type,terminating\_rule\_id,event.action,http\_source\_id,http\_source\_name, latitude, longitude, country\_code<br />\| (blocked + allowed) as requests<br />\| if(requests \> 0, blocked/requests, 0) as blocked\_pct<br />\| blocked\_pct as eventCount<br />\| sort + \_timeslice<br /><br />\| avg(eventCount) as avg\_blocked\_pct by \_timeslice|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Trend: Suspicious Traffic (Megabytes)|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Network Activity|\_sourceCategory=PDET/CIS/AWS/Vanta/Flow <br />\| json "firewall\_name", "availability\_zone", "event" as cloud.instance.name, cloud.availability\_zone, event nodrop<br />\| json field=event "event\_type", "src\_ip", "src\_port", "dest\_ip", "dest\_port", "proto", "app\_proto", "netflow" as event.type, server.ip, server.port, client.ip, client.port, network.protocol, app\_proto, netflow nodrop<br />\| where event.type="netflow"<br />\| json field=alert "severity", "signature", "action", "category" as risk.static\_level, signature, event.outcome, category nodrop<br />\| json field=netflow "bytes", "pkts" as network.bytes, packets nodrop<br /><br />// filters<br />\| where if ("{{server.ip}}" = "\*", true, server.ip matches "{{server.ip}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{cloud.availability\_zone}}" = "\*", true, cloud.availability\_zone matches "{{cloud.availability\_zone}}") AND if ("{{cloud.instance.name}}" = "\*", true, cloud.instance.name matches "{{cloud.instance.name}}") AND if ("{{network.protocol}}" = "\*", true, network.protocol matches "{{network.protocol}}")<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| network.bytes/1Mi as m\_bytes<br />\| sum(m\_bytes) as total\_mega\_bytes by \_timeslice<br />\| total\_mega\_bytes as eventCount<br />\| sort + \_timeslice<br /><br />\| avg(total\_mega\_bytes) as avg\_outbound\_megabytes by \_timeslice|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Unauthorized API Requests|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity|\_sourceCategory=\*CloudTrail\* ("AccessDenied" or "UnauthorizedOperation")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where !isBlank(event.action) or !isBlank(user.name)<br />\| where error\_code="AccessDenied" or error\_code="UnauthorizedOperation"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Unauthorized API Requests|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* ("AccessDenied" or "UnauthorizedOperation")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where !isBlank(event.action) or !isBlank(user.name)<br />\| where error\_code="AccessDenied" or error\_code="UnauthorizedOperation"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|Unauthorized AWS API Requests|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious User Activity|\_sourceCategory=\*CloudTrail\* ("AccessDenied" or "UnauthorizedOperation")<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,event\_source,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=event\_source "\*." as cloud.service.name<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where !isBlank(event.action) or !isBlank(user.name)<br />\| where error\_code="AccessDenied" or error\_code="UnauthorizedOperation"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by client.ip, user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches|VPC Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Saved Searches/VPC Changes|\_sourceCategory=\*CloudTrail\* ("CreateVpc" or "DeleteVpc" or "ModifyVpcAttribute" or \*VpcPeeringConnection or \*tachClassicLink or \*ableVpcClassic)<br />\| json "requestID","eventID","userIdentity.sessionContext.sessionIssuer.userName","userIdentity.accountId","sourceIPAddress","awsRegion","eventName","eventType" as request\_id, event\_id,user\_name,acc\_id,source\_ip,region,event\_name,event\_type nodrop<br /><br />// global filters<br />\| where user\_name matches "\*"<br />\| where region matches "\*"<br />\| where acc\_id matches "\*"<br />\| where event\_type matches "\*"<br /><br />\| where eventName matches "CreateVpc" or eventName matches "DeleteVpc" or eventName matches "ModifyVpcAttribute" or eventName matches "\*VpcPeeringConnection" or eventName matches "\*tachClassicLink" or eventName matches "\*ableVpcClassic"<br />\| count as frequency by user\_name,acc\_id<br />\| sort by frequency<br />\| limit 100|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|VPC Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("CreateVpc" or "DeleteVpc" or "ModifyVpcAttribute" or \*VpcPeeringConnection or \*tachClassicLink or \*ableVpcClassic)<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateVpc" or event.action matches "DeleteVpc" or event.action matches "ModifyVpcAttribute" or event.action matches "\*VpcPeeringConnection" or event.action matches "\*tachClassicLink" or event.action matches "\*ableVpcClassic"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|VPC Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Suspicious Config and IAM Activity|\_sourceCategory=\*CloudTrail\* ("CreateVpc" or "DeleteVpc" or "ModifyVpcAttribute" or \*VpcPeeringConnection or \*tachClassicLink or \*ableVpcClassic)<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateVpc" or event.action matches "DeleteVpc" or event.action matches "ModifyVpcAttribute" or event.action matches "\*VpcPeeringConnection" or event.action matches "\*tachClassicLink" or event.action matches "\*ableVpcClassic"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|
|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1|VPC Changes|Logs|Cloud Infrastructure Security for AWS 2024-03-13  - DEMO  V1.0.1/Risk Overview|\_sourceCategory=\*CloudTrail\* ("CreateVpc" or "DeleteVpc" or "ModifyVpcAttribute" or \*VpcPeeringConnection or \*tachClassicLink or \*ableVpcClassic)<br />\| json "eventName","sourceIPAddress","userIdentity.userName","userIdentity.principalId","responseElements.ConsoleLogin","additionalEventData.MFAUsed" ,"eventSource","awsRegion","eventType","eventCategory","userIdentity.type","eventTime","requestParameters.AccessControlPolicy.AccessControlList.Grant[\*].Permission","errorCode","userIdentity.accountId","errorMessage" as event.action,client.ip,user.name,user\_principal, login\_result,mfa\_used,service\_name,cloud.region,event\_type,event\_category,user\_identity\_type,event\_time,permission,error\_code,cloud.account.id,error\_message nodrop<br /><br />\| parse "\\"accessKeyId\\":\\"\*\\"" as accessKeyId nodrop<br />\| if(isEmpty(user.name), if(isEmpty(user\_principal),"NA",user\_principal), user.name) as user.name<br />\| if (user\_identity\_type in ("IAMUser","Root"), "Yes", "No") as source.user<br />\| if(isEmpty(cloud.account.id), "NA", cloud.account.id) as cloud.account.id<br />\| parse field=service\_name "\*." as cloud.service.name<br />\| json field=\_raw "userIdentity.sessionContext.sessionIssuer.userName" as user.name nodrop<br /><br />// global filters<br />\| where if ("{{cloud.account.id}}" = "\*", true, cloud.account.id matches "{{cloud.account.id}}") AND if ("{{cloud.region}}" = "\*", true, cloud.region matches "{{cloud.region}}") AND if ("{{user.name}}" = "\*", true,user.name matches "{{user.name}}") AND if ("{{client.ip}}" = "\*", true, client.ip matches "{{client.ip}}") AND if("{{source.user}}" = "\*", true, source.user matches "{{source.user}}")<br /><br />\| where event.action matches "CreateVpc" or event.action matches "DeleteVpc" or event.action matches "ModifyVpcAttribute" or event.action matches "\*VpcPeeringConnection" or event.action matches "\*tachClassicLink" or event.action matches "\*ableVpcClassic"<br /><br />// z-score calculation<br />\| timeslice 3h<br />\| count as eventCount by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region, \_timeslice<br />\| sort + \_timeslice<br />\| rollingstd eventCount as eventCount\_std by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| smooth eventCount as eventCount\_mean by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| eventCount\_std + 0.1 as eventCount\_std<br />\| (eventCount - eventCount\_mean) / eventCount\_std as zscore<br />\| sort + \_timeslice<br /><br />\| max(zscore) as max\_zscore by user.name, event.action, cloud.service.name, cloud.account.id, cloud.region<br />\| round(max\_zscore, 2) as max\_zscore<br />\| where if ("{{risk.static\_level}}" = "\*", true, max\_zscore \>= toInt("{{risk.static\_level}}"))<br />\| sort - max\_zscore<br /><br />\| count|

