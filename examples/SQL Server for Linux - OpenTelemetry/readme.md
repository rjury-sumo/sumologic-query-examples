# SQL Server for Linux - OpenTelemetry

## Searches

### Log Searches

- **Appdomain Issue count**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview 
- **AppDomain Issues**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - General Health 
- **Backup Failure Count**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview 
- **Backup Failure Reasons**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Backup Restore Mirroring 
- **Backup Failures**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Backup Restore Mirroring 
- **Configuration Update Trend**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Operations 
- **Configuration Updates**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Operations 
- **Database Backed Up**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Backup Restore Mirroring 
- **Deadlock Count**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview 
- **Deadlocks**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - General Health 
- **Error or Warning Count**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview 
- **Error Trend?by Severity Code**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Operations 
- **Errors and Warnings**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Operations 
- **Errors and Warnings**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Operations 
- **Insufficient Space Issues**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - General Health 
- **Insufficient space issues Count**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview 
- **Login Failure Reasons**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview 
- **Login Failures**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview 
- **Logins by Authentication Method**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview 
- **Mirroring Error Count**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview 
- **Mirroring Errors**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Backup Restore Mirroring 
- **Recent Configuration Updates**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Operations 
- **Restore Activity**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Backup Restore Mirroring 
- **Server Events**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - General Health 
- **Stopped Servers**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - General Health 
- **Top 10 Client IP Addresses by Login Count**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview 
- **Top 10 Users by Login Count**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview 
- **Transaction Log Backed Up**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Backup Restore Mirroring 
- **Up Servers**: from Dashboard: Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - General Health

### Metric Searches


## Search Table

|app\_topic|search\_name|type|origin|search|
|:--|:--|:--|:--|:--|
|SQL Server for Linux - OpenTelemetry|Appdomain Issue count|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}}  sumo.datasource=sqlserver  (AppDomain or "memory pressure" or "out of memory") \|json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw<br />\| parse "AppDomain \* (\*) is marked for unload due to \*." as AppDomainID, detail, reason nodrop<br />\| parse "AppDomain \* was unloaded by escalation policy to ensure the consistency of your application. \* happened while accessing a critical resource" as detail, reason nodrop<br />\| Parse "Failed to initialize the Common Language Runtime \* due to \*." as detail, reason nodrop<br />\| parse "Error: \*, Severity: \*, State: \*. .NET Framework execution was aborted by escalation policy because of \*." as error, severity, state, reason<br />\| count|
|SQL Server for Linux - OpenTelemetry|AppDomain Issues|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - General Health| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}} sumo.datasource=sqlserver  (AppDomain or "memory pressure" or "out of memory") \|json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw<br />\| parse "AppDomain \* (\*) is marked for unload due to \*." as AppDomainID, detail, reason nodrop<br />\| parse "AppDomain \* was unloaded by escalation policy to ensure the consistency of your application. \* happened while accessing a critical resource" as detail, reason nodrop<br />\| Parse "Failed to initialize the Common Language Runtime \* due to \*." as detail, reason nodrop<br />\| parse "Error: \*, Severity: \*, State: \*. .NET Framework execution was aborted by escalation policy because of \*." as error, severity, state, reason<br />\| timeslice 1d<br />\| count by \_timeslice|
|SQL Server for Linux - OpenTelemetry|Backup Failure Count|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}}  sumo.datasource=sqlserver backup !Restore !"[180] Job" \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "BackupDiskFile::\*: Backup device '\*' \* to \*. Operating system error \*(\*)." as media, backup\_path, backup\_status, operation, error\_code, reason nodrop<br />\| parse "Backup      BackupIoRequest::ReportIoError: \* \* on backup device '\*'. Operating system error \*(\*)." as operation, backup\_status, backup\_path, error\_code, reason nodrop<br />\| parse "Extend Disk Backup:  \* on backup device '\*'. Operating system error \*(\*)." as backup\_status, backup\_path, error\_code, reason nodrop<br />\| parse "BackupVirtualDeviceFile::RequestDurableMedia: \* \* on backup device '\*'. Operating system error \*(\*)." as operation, backup\_status, backup\_path, error\_code, reason nodrop<br />\| parse "Backup      BACKUP \* to complete the command BACKUP DATABASE \*. Check the backup application log for detailed messages." as backup\_status, database<br />\| if (backup\_status in ("failed", "failure"), "Failure", backup\_status) as backup\_status<br />\| count by backup\_status|
|SQL Server for Linux - OpenTelemetry|Backup Failure Reasons|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Backup Restore Mirroring| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}} sumo.datasource=sqlserver !Restore !"[180] Job" \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "BackupDiskFile::\*: Backup device '\*' \* to \*. Operating system error \*(\*)." as media, backup\_path, backup\_status, operation, error\_code, reason nodrop<br />\| parse "Backup      BackupIoRequest::ReportIoError: \* \* on backup device '\*'. Operating system error \*(\*)." as operation, backup\_status, backup\_path, error\_code, reason nodrop<br />\| parse "Extend Disk Backup:  \* on backup device '\*'. Operating system error \*(\*)." as backup\_status, backup\_path, error\_code, reason nodrop<br />\| parse "BackupVirtualDeviceFile::RequestDurableMedia: \* \* on backup device '\*'. Operating system error \*(\*)." as operation, backup\_status, backup\_path, error\_code, reason nodrop<br />\| parse "Backup      BACKUP \* to complete the command BACKUP DATABASE \*. Check the backup application log for detailed messages." as backup\_status, database<br />\| if (backup\_status in ("failed", "failure"), "Failure", backup\_status) as backup\_status<br />\| if (reason = "" or isNull(reason), "Unknown", reason) as reason <br />\| count as count by reason \| sort by count|
|SQL Server for Linux - OpenTelemetry|Backup Failures|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Backup Restore Mirroring| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}} sumo.datasource=sqlserver backup !Restore !"[180] Job" \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "BackupDiskFile::\*: Backup device '\*' \* to \*. Operating system error \*(\*)." as media, backup\_path, backup\_status, operation, error\_code, reason nodrop<br />\| parse "Backup      BackupIoRequest::ReportIoError: \* \* on backup device '\*'. Operating system error \*(\*)." as operation, backup\_status, backup\_path, error\_code, reason nodrop<br />\| parse "Extend Disk Backup:  \* on backup device '\*'. Operating system error \*(\*)." as backup\_status, backup\_path, error\_code, reason nodrop<br />\| parse "BackupVirtualDeviceFile::RequestDurableMedia: \* \* on backup device '\*'. Operating system error \*(\*)." as operation, backup\_status, backup\_path, error\_code, reason nodrop<br />\| parse "Backup      BACKUP \* to complete the command BACKUP DATABASE \*. Check the backup application log for detailed messages." as backup\_status, database<br />\| if (backup\_status in ("failed", "failure"), "Failure", backup\_status) as backup\_status<br />\| timeslice 1d<br />\| count by \_timeslice, backup\_status<br />\| transpose row \_timeslice column backup\_status|
|SQL Server for Linux - OpenTelemetry|Configuration Update Trend|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Operations| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}} sumo.datasource=sqlserver option \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "Configuration option '\*' changed from \* to \*." as object, old\_val, new\_val nodrop<br />\| parse	"Setting database option \* to \* for database '\*'." as object, new\_val, database<br />\| where old\_val != new\_val<br />\| timeslice 1h<br />\| count by \_timeslice|
|SQL Server for Linux - OpenTelemetry|Configuration Updates|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Operations| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}} sumo.datasource=sqlserver option \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "Configuration option '\*' changed from \* to \*." as object, old\_val, new\_val nodrop<br />\| parse	"Setting database option \* to \* for database '\*'." as object, new\_val, database<br />\| where old\_val != new\_val<br />\| count as count by object \| sort by count|
|SQL Server for Linux - OpenTelemetry|Database Backed Up|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Backup Restore Mirroring| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}}  sumo.datasource=sqlserver backup \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "Backup      Database backed up. Database: \*, creation date(time): \*, pages dumped: \*, first LSN: \*, last LSN: \*, number of dump devices: \*, device information: \*. This is an informational message only. No user action is required." as database, creation\_time, pages\_dumped, first\_lsn, last\_lsn,dump\_devices, device\_info<br />\| timeslice 1d<br />\| count by \_timeslice|
|SQL Server for Linux - OpenTelemetry|Deadlock Count|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} sumo.datasource=sqlserver deadlocked\| count|
|SQL Server for Linux - OpenTelemetry|Deadlocks|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - General Health| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}} sumo.datasource=sqlserver deadlocked<br />\| timeslice 1d<br />\| count as count by \_timeslice|
|SQL Server for Linux - OpenTelemetry|Error or Warning Count|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}}  sumo.datasource=sqlserver ("Error:" or "Warning:") \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse regex "\\s+(?\<Logtype\>Error\|Warning):\\s+(?\<message\>.\*)\$"<br />\| count by LogType|
|SQL Server for Linux - OpenTelemetry|Error Trend?by Severity Code|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Operations| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}}  sumo.datasource=sqlserver "Error:" "Severity:" \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse regex "\\s+(?\<Logtype\>Error):\\s+(?\<message\>.\*)\$"<br />\| parse field=message "\*, Severity: \*, State:" as error\_code, severity<br />\| int(severity) as severity<br />\| where Logtype = "Error" and severity \> 16<br />\| timeslice 1d<br />\| count by \_timeslice, severity <br />\| transpose row \_timeslice column severity|
|SQL Server for Linux - OpenTelemetry|Errors and Warnings|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Operations| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}} sumo.datasource=sqlserver("Error:" or "Warning:") \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse regex "\\s+(?\<Logtype\>Error\|Warning):\\s+(?\<message\>.\*)\$"<br />\| timeslice 1d<br />\| count by \_timeslice, LogType<br />\| transpose row \_timeslice column LogType|
|SQL Server for Linux - OpenTelemetry|Errors and Warnings|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Operations| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}} sumo.datasource=sqlserver ("Error:" or "Warning:") \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse regex "\\s+(?\<Logtype\>Error\|Warning):\\s+(?\<message\>.\*)\$"<br />\| count by LogType|
|SQL Server for Linux - OpenTelemetry|Insufficient Space Issues|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - General Health| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}} sumo.datasource=sqlserver "Could not allocate" (space or page) \|json "log" as \_rawlog nodrop \| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw<br />\| parse "Could not allocate space for object '\*' in database '\*' because \*. Create disk space by deleting unneeded files, dropping objects in the filegroup, adding additional files to the filegroup, or setting autogrowth on for existing files in the filegroup." as object, database, reason nodrop<br />\| parse "Could not allocate a new \* for database '\*' because \*. Create the necessary space by dropping objects in the filegroup, adding additional files to the filegroup, or setting autogrowth on for existing files in the filegroup." as object, database, reason<br />\| timeslice 1d<br />\| count by \_timeslice|
|SQL Server for Linux - OpenTelemetry|Insufficient space issues Count|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}}  sumo.datasource=sqlserver "Could not allocate" (space or page) \|json "log" as \_rawlog nodrop \| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw<br />\| parse "Could not allocate space for object '\*' in database '\*' because \*. Create disk space by deleting unneeded files, dropping objects in the filegroup, adding additional files to the filegroup, or setting autogrowth on for existing files in the filegroup." as object, database, reason nodrop<br />\| parse "Could not allocate a new \* for database '\*' because \*. Create the necessary space by dropping objects in the filegroup, adding additional files to the filegroup, or setting autogrowth on for existing files in the filegroup." as object, database, reason<br />\| count|
|SQL Server for Linux - OpenTelemetry|Login Failure Reasons|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} sumo.datasource=sqlserver Logon \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "Logon       Login \* for user '\*'. Reason: \* '\*'. [CLIENT: \*]" as logon\_status, userName, reason, database, client\_ip nodrop<br />\| parse "Logon       Login \* for user '\*'. Reason: \*. [CLIENT: \*]" as logon\_status, userName, reason, client\_ip nodrop<br />\| parse "Logon       Login \* for user '\*' because \*  [CLIENT: \*]" as logon\_status, userName, reason, client\_ip nodrop<br />\| parse "Logon       SSPI handshake \* with error code \*, state \* while establishing a connection with integrated security; the connection has been closed. Reason: \*.  [CLIENT: \*]." as logon\_status, error\_code, state, reason, client\_ip nodrop<br />\| parse "Logon       \* database '\*' because \*" as logon\_status, database, reason nodrop<br />\| parse "Logon       The target database, '\*', is participating in an availability group and is currently \* for queries. \*" as database, logon\_status, reason<br />\| parse field=reason "\* '\*'" as reason, database nodrop<br />\| count as count by reason<br />\| sort by count|
|SQL Server for Linux - OpenTelemetry|Login Failures|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}}  sumo.datasource=sqlserver Logon \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "Logon       Login \* for user '\*'. Reason: \* '\*'. [CLIENT: \*]" as logon\_status, userName, reason, database, client\_ip nodrop<br />\| parse "Logon       Login \* for user '\*'. Reason: \*. [CLIENT: \*]" as logon\_status, userName, reason, client\_ip nodrop<br />\| parse "Logon       Login \* for user '\*' because \*  [CLIENT: \*]" as logon\_status, userName, reason, client\_ip nodrop<br />\| parse "Logon       SSPI handshake \* with error code \*, state \* while establishing a connection with integrated security; the connection has been closed. Reason: \*.  [CLIENT: \*]." as logon\_status, error\_code, state, reason, client\_ip nodrop<br />\| parse "Logon       \* database '\*' because \*" as logon\_status, database, reason nodrop<br />\| parse "Logon       The target database, '\*', is participating in an availability group and is currently \* for queries. \*" as database, logon\_status, reason<br />\| timeslice 1h<br />\| count by \_timeslice, logon\_status<br />\| transpose row \_timeslice column logon\_status|
|SQL Server for Linux - OpenTelemetry|Logins by Authentication Method|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} sumo.datasource=sqlserver Logon succeeded \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "Logon       Login \* for user '\*'. Connection made using \*. [CLIENT: \*]" as logon\_status, userName, authentication\_method, client\_ip <br />\| where logon\_status = "succeeded"<br />\| timeslice 1h<br />\| count by \_timeslice, authentication\_method<br />\| transpose row \_timeslice column authentication\_method|
|SQL Server for Linux - OpenTelemetry|Mirroring Error Count|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}}  sumo.datasource=sqlserver mirror\* \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "A \* has occurred while attempting to establish a connection to availability replica '\*' with id [\*]." as reason, replica, replicaID nodrop<br />\| parse "An error occurred in a Service Broker/Database Mirroring transport connection endpoint, Error: \*, State: \*. (Near endpoint role: \*, far endpoint address: \*)" as error, state, near\_endpoint, far\_endpoint<br />\| count|
|SQL Server for Linux - OpenTelemetry|Mirroring Errors|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Backup Restore Mirroring| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}} sumo.datasource=sqlserver mirror\* \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "A \* has occurred while attempting to establish a connection to availability replica '\*' with id [\*]." as reason, replica, replicaID nodrop<br />\| parse "An error occurred in a Service Broker/Database Mirroring transport connection endpoint, Error: \*, State: \*. (Near endpoint role: \*, far endpoint address: \*)" as error, state, near\_endpoint, far\_endpoint<br />\| timeslice 1d<br />\| count by \_timeslice|
|SQL Server for Linux - OpenTelemetry|Recent Configuration Updates|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Operations| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}} sumo.datasource=sqlserver option \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "Configuration option '\*' changed from \* to \*." as object, old\_val, new\_val nodrop<br />\| parse	"Setting database option \* to \* for database '\*'." as object, new\_val, database<br />\| where old\_val != new\_val<br />\| timeslice 1m<br />\| fields \_timeslice, db.node.name, object, old\_val, new\_val<br />\| count by \_timeslice, db.node.name, object, old\_val, new\_val \| fields -\_count|
|SQL Server for Linux - OpenTelemetry|Restore Activity|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Backup Restore Mirroring| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}}  sumo.datasource=sqlserver (restore or restoring) \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "Backup      Restore is \* on database '\*'.  The database is now available." as restore\_status, database nodrop<br />\| parse "The database \* is marked \* and is in a state that does not allow recovery to be run." as database, restore\_status<br />\| timeslice 1d<br />\| count by \_timeslice, restore\_status<br />\| transpose row \_timeslice column restore\_status|
|SQL Server for Linux - OpenTelemetry|Server Events|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - General Health| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}} sumo.datasource=sqlserver \|json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw<br />\| where \_raw matches "\*SQL Server is now ready for client connections.\*" or  \_raw matches "\*SQL Server is allowing new connections in response to 'continue' request from Service Control Manager.\*" or  \_raw matches "\*SQL Server is not allowing new connections because the Service Control Manager requested a pause\*" or  \_raw matches "\*SQL Trace was stopped due to server shutdown.\*" or "\*SQL Server terminating because of system shutdown.\*"<br />\| parse regex "(?\<time\>\\d{4}-\\d{2}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2}.\\d{2,3})\\s+\\S+"<br />\| if (\_raw matches "\*SQL Server is now ready for client connections.\*", "Up", if (\_raw matches "\*SQL Server is allowing new connections in response to 'continue' request from Service Control Manager.\*", "Up",  if (\_raw matches "\*SQL Server is not allowing new connections because the Service Control Manager requested a pause.\*", "Down", if (\_raw matches "\*SQL Trace was stopped due to server shutdown.\*" or \_raw matches "\*SQL Server terminating because of system shutdown.\*", "Down", "Unkown" )))) as server\_status<br />\| timeslice 1h<br />\| count by \_timeslice, server\_status<br />\| transpose row \_timeslice column server\_status|
|SQL Server for Linux - OpenTelemetry|Stopped Servers|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - General Health| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}} sumo.datasource=sqlserver \|json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw<br />\| where \_raw matches "\*SQL Server is now ready for client connections.\*" or  \_raw matches "\*SQL Server is allowing new connections in response to 'continue' request from Service Control Manager.\*" or  \_raw matches "\*SQL Server is not allowing new connections because the Service Control Manager requested a pause\*" or  \_raw matches "\*SQL Trace was stopped due to server shutdown.\*" or "\*SQL Server terminating because of system shutdown.\*"<br />\| parse regex "(?\<time\>\\d{4}-\\d{2}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2}.\\d{2,3})\\s+\\S+"<br />\| if (\_raw matches "\*SQL Server is now ready for client connections.\*", "Up", if (\_raw matches "\*SQL Server is allowing new connections in response to 'continue' request from Service Control Manager.\*", "Up",  if (\_raw matches "\*SQL Server is not allowing new connections because the Service Control Manager requested a pause.\*", "Down", if (\_raw matches "\*SQL Trace was stopped due to server shutdown.\*" or \_raw matches "\*SQL Server terminating because of system shutdown.\*", "Down", "Unkown" )))) as server\_status<br />\| where !(server\_status="Up")<br />\| timeslice 100s<br />\| withtime server\_status \| withtime \_messagetime<br />\| most\_recent(server\_status\_withtime) as server\_status, most\_recent(\_messagetime\_withtime) as m\_time by db.node.name<br />\| formatDate(fromMillis(m\_time), "MM-dd-yyyy HH:mm:ss:SSS", "UTC") as event\_time<br />\| ((toMillis(now())-m\_time)/(1000\*60)) as since\_mins \| format("%.2f", since\_mins) as since\_minutes<br />\| concat ("Since ", since\_minutes, " minutes") as downtime<br />\| fields db.node.name, event\_time, server\_status, downtime|
|SQL Server for Linux - OpenTelemetry|Top 10 Client IP Addresses by Login Count|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}}  sumo.datasource=sqlserver Logon succeeded \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "Logon       Login \* for user '\*'. Connection made using \*. [CLIENT: \*]" as logon\_status, userName, authentication\_method, client\_ip <br />\| where logon\_status = "succeeded"<br />\| timeslice 1h<br />\| count by client\_ip \| top 10 client\_ip by \_count \| \_count as logincount \| fields -\_count|
|SQL Server for Linux - OpenTelemetry|Top 10 Users by Login Count|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Overview| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} sumo.datasource=sqlserver Logon succeeded \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "Logon       Login \* for user '\*'. Connection made using \*. [CLIENT: \*]" as logon\_status, userName, authentication\_method, client\_ip <br />\| where logon\_status = "succeeded"<br />\| timeslice 1h<br />\| count by userName \| top 10 userName by \_count \| \_count as logincount \| userName as user \| fields user, logincount|
|SQL Server for Linux - OpenTelemetry|Transaction Log Backed Up|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - Backup Restore Mirroring| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}}  sumo.datasource=sqlserver backup \| json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw <br />\| parse "Backup      Database backed up. Database: \*, creation date(time): \*, first LSN: \*, last LSN: \*, number of dump devices: \*, device information: \*. This is an informational message only. No user action is required." as database, creation\_time, first\_lsn, last\_lsn, dump\_devices, device\_info<br />\| timeslice 1d<br />\| count by \_timeslice|
|SQL Server for Linux - OpenTelemetry|Up Servers|Logs|Installed Apps/SQL Server for Linux - OpenTelemetry/SQL Server - General Health| db.cluster.name={{db.cluster.name}} deployment.environment={{deployment.environment}} db.node.name={{db.node.name}} sumo.datasource=sqlserver \|json "log" as \_rawlog nodrop <br />\| if (isEmpty(\_rawlog), \_raw, \_rawlog) as \_raw<br />\| where \_raw matches "\*SQL Server is now ready for client connections.\*" or  \_raw matches "\*SQL Server is allowing new connections in response to 'continue' request from Service Control Manager.\*" or  \_raw matches "\*SQL Server is not allowing new connections because the Service Control Manager requested a pause\*" or  \_raw matches "\*SQL Trace was stopped due to server shutdown." or "SQL Server terminating because of system shutdown.\*"<br />\| parse regex "(?\<time\>\\d{4}-\\d{2}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2}.\\d{2,3})\\s+\\S+"<br />\| if (\_raw matches "\*SQL Server is now ready for client connections.\*", "Up", if (\_raw matches "\*SQL Server is allowing new connections in response to 'continue' request from Service Control Manager.\*", "Up",  if (\_raw matches "\*SQL Server is not allowing new connections because the Service Control Manager requested a pause.\*", "Down", if (\_raw matches "\*SQL Trace was stopped due to server shutdown.\*" or \_raw matches "\*SQL Server terminating because of system shutdown.\*", "Down", "Unkown" )))) as server\_status<br />\| where server\_status = "Up"<br />\| timeslice 100s<br />\| withtime server\_status \| withtime \_messagetime<br />\| most\_recent(server\_status\_withtime) as server\_status, most\_recent(\_messagetime\_withtime) as m\_time by db.node.name<br />\| formatDate(fromMillis(m\_time), "MM-dd-yyyy HH:mm:ss:SSS", "UTC") as event\_time<br />\| ((toMillis(now())-m\_time)/(1000\*60)) as since\_mins \| format("%.2f", since\_mins) as since\_minutes<br />\| concat ("Since ", since\_minutes, " minutes") as uptime<br />//\| fields - m\_time, since\_mins, since\_minutes <br />\| fields db.node.name, event\_time, server\_status, uptime|

